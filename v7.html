<!-- Enhanced CSV Chart Generator with responsive UI and smart data visualization -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced CSV Chart Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment@1.0.0/dist/chartjs-adapter-moment.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-stacked100@1.0.0/build/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        #chartContainer { 
            width: 100%; 
            max-width: 100%; 
            height: 60vh; 
            min-height: 300px; 
            overflow-x: auto; 
            overflow-y: auto; 
            margin: 1rem auto 1rem auto; 
            background-color: #f9fafb; 
            border-radius: 0.5rem; 
            padding: 1rem; 
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06); 
            position: relative; 
        }
        #chartWrapper { 
            margin: 0 auto; 
            position: relative; 
            transition: width 0.3s ease, height 0.3s ease;
            /* Ensure the wrapper has no max-height constraint and can grow as needed */
            max-height: none;
        }
        #myChart { 
            display: block; 
            width: 100%;
            height: 100%;
        }
        #dataTableContainer { 
            margin-top: 1.5rem; 
            overflow-y: visible;
        }
        .preview-mode-indicator { 
            position: absolute; 
            top: 10px; 
            right: 10px; 
            background: rgba(0,0,0,0.6); 
            color: white; 
            padding: 5px 10px; 
            border-radius: 4px; 
            font-size: 12px; 
            z-index: 10; 
            opacity: 1;
            transition: opacity 0.5s ease-in-out;
        }
        .preview-mode-indicator.fade-out {
            opacity: 0;
        }
        .preview-mode-indicator.hidden {
            display: none;
        }
        button:disabled, input:disabled, select:disabled, input[type=checkbox]:disabled + .toggle-slider { opacity: 0.5; cursor: not-allowed; }
        input[type="file"]::file-selector-button { display: none;}
        input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        input[type=number] { -moz-appearance: textfield; }
        input[type=range] { -webkit-appearance: none; appearance: none; width: 100%; height: 8px; background: #ddd; border-radius: 5px; outline: none; opacity: 0.7; -webkit-transition: .2s; transition: opacity .2s; }
        input[type=range]:hover { opacity: 1; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; background: #3b82f6; border-radius: 50%; cursor: pointer; }
        input[type=range]::-moz-range-thumb { width: 18px; height: 18px; background: #3b82f6; border-radius: 50%; cursor: pointer; border: none; }
        #dataTable th, #dataTable td { 
            padding: 0.25rem 0.5rem; 
            text-align: left; 
            font-size: 0.75rem; 
            border-bottom: 1px solid #e5e7eb; 
            white-space: nowrap; 
        }
        #dataTable thead th { 
            background-color: #f3f4f6; 
            font-weight: 600; 
            color: #374151; 
            position: sticky; 
            top: 0; 
            z-index: 11; 
        }
        #dataTable tbody tr:nth-child(even) { background-color: #f9fafb; }
        #dataTable thead th:first-child, #dataTable tbody th:first-child { position: sticky; left: 0; background-color: #f3f4f6; z-index: 12; min-width: 50px; text-align: center; border-right: 1px solid #e5e7eb; }
        #dataTable tbody th:first-child { font-weight: normal; color: #4b5563; background-color: #f9fafb; z-index: 10;}
        #dataTable tbody tr:nth-child(even) th:first-child { background-color: #f3f4f6; }
        /* Toggle Switch Styles */
        .toggle-label { display: flex; align-items: center; cursor: pointer; min-height: 20px; }
        .toggle-label span:first-child { flex-shrink: 0; padding-right: 5px;}
        .toggle-label.disabled { cursor: not-allowed; color: #9ca3af; }
        .toggle-switch { position: relative; display: inline-block; width: 40px; height: 20px; margin-left: auto; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; border-radius: 20px; transition: .4s; }
        .toggle-slider:before { position: absolute; content: ""; height: 14px; width: 14px; left: 3px; bottom: 3px; background-color: white; border-radius: 50%; transition: .4s; }
        input:checked + .toggle-slider { background-color: #3b82f6; }
        input:checked + .toggle-slider:before { transform: translateX(20px); }
        input:disabled + .toggle-slider { background-color: #e5e7eb; cursor: not-allowed; }
        /* Small Toggle Switch */
        .toggle-switch-sm { width: 30px; height: 16px; }
        .toggle-switch-sm .toggle-slider:before { height: 10px; width: 10px; left: 3px; bottom: 3px; }
        .toggle-switch-sm input:checked + .toggle-slider:before { transform: translateX(14px); }
        /* Drag and Drop Zone */
        #dropZone { transition: all 0.3s ease; padding: 1rem; }
        #dropZone svg { width: 2.5rem; height: 2.5rem; margin-bottom: 0.25rem; }
        #dropZone.drag-active { border-color: #3b82f6; background-color: #f0f7ff; }
        /* Color Assignment Style */
        .color-assign-select {
            padding: 0.3rem 0.5rem;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-left: 8px;
            vertical-align: middle;
            cursor: pointer;
            max-width: 150px; /* Limit width */
        }
        .color-assign-option-color { /* Style for color swatch in option */
            display: inline-block;
            width: 1em;
            height: 1em;
            margin-right: 0.5em;
            border: 1px solid #ccc;
            vertical-align: middle;
            border-radius: 2px;
        }
        
        /* Two-column layout styles */
        .split-layout {
            display: flex;
            width: 100%;
            height: calc(100vh - 80px);
            overflow: hidden;
        }
        
        .left-panel {
            flex: 0 0 21%;
            min-width: 300px;
            max-width: 360px;
            overflow-y: auto;
            padding: 20px;
            background-color: white;
            border-right: none;
            transition: flex 0.3s ease;
        }
        
        .right-panel {
            flex: 1;
            min-width: 30%;
            overflow-y: auto;
            padding: 20px;
            background-color: white;
            transition: flex 0.3s ease;
            display: flex;
            flex-direction: column;
        }
        
        .resize-handle {
            flex: 0 0 6px;
            background-color: #e5e7eb;
            cursor: col-resize;
            position: relative;
            transition: background-color 0.2s;
        }
        
        .resize-handle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            height: 50px;
            width: 2px;
            background-color: #94a3b8;
            border-radius: 3px;
        }
        
        .resize-handle:hover, .resize-handle.active {
            background-color: #94a3b8;
        }
        
        .resize-handle:hover::after, .resize-handle.active::after {
            background-color: #3b82f6;
        }
        
        /* Section titles in panels */
        .panel-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #1f2937;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 0.5rem;
        }
        
        /* Panel title when in flex layout */
        .panel-title.mb-0 {
            margin-bottom: 0;
            border-bottom: none;
            padding-bottom: 0;
        }
        
        /* Adjust heights for right panel content */
        .right-panel #dataTableContainer {
            margin-bottom: 1.5rem;
            overflow-y: visible;
        }
        
        /* Data table scroll container - allows table to scroll while keeping title fixed */
        .data-table-scroll-container {
            overflow-x: auto;
            overflow-y: auto;
            margin-top: 0.5rem;
        }
        
        .right-panel #chartContainer {
            display: flex;
            flex-direction: column;
            min-height: 400px;
            /* Allow the container to grow as needed */
            flex: 1 1 auto;
            /* Ensure scrollbar appears when content exceeds container height */
            overflow-y: auto;
        }
        
        /* Remove outer container margins */
        .container-wrapper {
            margin: 0;
            padding: 0;
            max-width: none;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">

    <div class="container-wrapper">
        <h1 class="text-2xl md:text-3xl font-bold py-4 px-6 bg-white border-b text-center text-gray-800">Enhanced CSV Chart Generator</h1>

        <div id="messageArea" class="mx-6 mb-4 p-3 rounded-md text-sm hidden bg-red-100 text-red-700 border border-red-200"></div>
        <div id="statusMessageArea" class="mx-6 mb-4 p-3 rounded-md text-sm hidden bg-blue-100 text-blue-700 border border-blue-200"></div>

        <div class="split-layout">
            <!-- Left Panel - Controls -->
            <div class="left-panel">
                <div class="mb-6 pb-6">
                    <h2 class="panel-title">1. Upload Data</h2>
            <button id="downloadSampleBtn" class="text-blue-600 hover:text-blue-800 text-sm font-medium mb-4 flex items-center">
                <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
                Download Sample CSV
            </button>
            <div id="dropZone" class="flex flex-col items-center justify-center border-2 border-dashed border-gray-300 rounded-lg p-4 mb-4 cursor-pointer hover:border-blue-400 transition-colors">
                <svg class="w-10 h-10 text-gray-400 mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path></svg>
                <p class="text-sm text-gray-600 mb-1">Drag and drop CSV file here</p>
                <p class="text-xs text-gray-500">or</p>
                <input type="file" id="csvFile" accept=".csv" class="hidden"/>
                <label for="csvFile" class="mt-2 bg-blue-50 text-blue-700 px-4 py-2 rounded-md text-sm font-medium hover:bg-blue-100 cursor-pointer transition-colors"> Select File </label>
            </div>
             <p class="text-xs text-gray-500 mt-2">Assumes first row contains headers and first column contains labels or dates.</p>
        </div>

                <div id="configSection" class="mb-6 pb-6 hidden">
                    <h2 class="panel-title">2. Configuration</h2>
             <div class="mb-6 border-b border-gray-200 pb-4">
                 <h3 class="text-md font-medium text-gray-800 mb-3">Display Options</h3>
                 <div class="space-y-3">
                    <label class="toggle-label text-sm text-gray-700" for="toggleTranspose" id="toggleTransposeLabel"> <span>Transpose Rows/Columns</span> <div class="toggle-switch"> <input type="checkbox" id="toggleTranspose"> <span class="toggle-slider"></span> </div> </label>
                    <label class="toggle-label text-sm text-gray-700" for="toggleUseFirstRowAsHeaders" id="toggleUseFirstRowAsHeadersLabel"> 
                        <span id="useHeadersToggleText">Use row 1 as headers</span> 
                        <div class="toggle-switch"> 
                            <input type="checkbox" id="toggleUseFirstRowAsHeaders" checked> 
                            <span class="toggle-slider"></span> 
                        </div> 
                    </label>
                </div>
            </div>
             <h3 class="text-md font-medium text-gray-800 mb-3">Chart Settings</h3>
                    <div class="grid grid-cols-1 gap-4 mb-4">
                 <!-- Chart Type Group -->
                 <div id="chartType" class="mb-4">
                     <div>
                         <label for="chartTypeSelect" class="block mb-1 text-sm font-medium text-gray-700">Chart Type:</label>
                         <select id="chartTypeSelect" disabled class="block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                             <option value="column" selected>Column Chart</option>
                             <option value="columnStacked">Stacked Column</option>
                             <option value="columnStacked100">100% Stacked Column</option>
                             <option value="line">Line Chart</option>
                             <option value="bar">Bar Chart (Horizontal)</option>
                             <option value="barStacked">Stacked Bar (Horizontal)</option>
                             <option value="barStacked100">100% Stacked Bar (Horizontal)</option>
                             <option value="pie">Pie Chart</option>
                             <option value="doughnut">Doughnut Chart</option>
                             <option value="area">Area Chart</option>
                             <option value="areaStacked">Stacked Area Chart</option>
                         </select>
                     </div>
                     <!-- Bar Chart Settings -->
                     <div id="barSettings" class="grid grid-cols-1 gap-4 mt-3"> 
                         <div>
                             <label for="barPercentageInput" class="block mb-1 text-sm font-medium text-gray-700">Bar Width (%): <span id="barPercValue" class="text-xs">1</span></label>
                             <input type="range" id="barPercentageInput" min="0.1" max="1" step="0.05" value="1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                         </div>
                         <div>
                             <label for="categoryPercentageInput" class="block mb-1 text-sm font-medium text-gray-700">Category Spacing (%): <span id="catPercValue" class="text-xs">0.8</span></label>
                             <input type="range" id="categoryPercentageInput" min="0.1" max="1" step="0.05" value="0.8" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                         </div>
                     </div>
                     <!-- Line Chart Settings -->
                     <div id="lineSettings" class="grid grid-cols-1 gap-4 hidden mt-3"> 
                         <div>
                             <label class="toggle-label text-sm text-gray-700" for="toggleCurvedLines">
                                 <span>Curved Lines</span>
                                 <div class="toggle-switch">
                                     <input type="checkbox" id="toggleCurvedLines">
                                     <span class="toggle-slider"></span>
                                 </div>
                             </label>
                         </div>
                         <div id="curveSettingsContainer">
                             <label for="lineTensionInput" class="block mb-1 text-sm font-medium text-gray-700">Curve Smoothness: <span id="lineTensionValue" class="text-xs">0.4</span></label>
                             <input type="range" id="lineTensionInput" min="0" max="1" step="0.1" value="0.4" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                         </div>
                         <!-- Line Width Slider -->
                         <div>
                             <label for="lineWidthInput" class="block mb-1 text-sm font-medium text-gray-700">Line Width: <span id="lineWidthValue" class="text-xs">2</span>px</label>
                             <input type="range" id="lineWidthInput" min="1" max="10" step="1" value="2" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                         </div>
                     </div>
                     <!-- Doughnut Chart Settings -->
                     <div id="doughnutSettings" class="grid grid-cols-1 gap-4 hidden mt-3"> 
                         <div>
                             <label for="innerRadiusInput" class="block mb-1 text-sm font-medium text-gray-700">Inner Radius (%): <span id="innerRadiusValue" class="text-xs">50</span></label>
                             <input type="range" id="innerRadiusInput" min="0" max="90" step="5" value="50" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                         </div>
                     </div>
                     <!-- Pie Chart Settings -->
                     <div id="pieChartSettings" class="grid grid-cols-1 gap-4 hidden mt-3"> 
                         <div>
                             <label for="toggleDataLabels" class="toggle-label text-sm text-gray-700">
                                 <span>Show Data Labels</span>
                                 <div class="toggle-switch">
                                     <input type="checkbox" id="toggleDataLabels" checked>
                                     <span class="toggle-slider"></span>
                                 </div>
                             </label>
                         </div>
                         <div>
                             <label for="dataLabelSizeInput" class="block mb-1 text-sm font-medium text-gray-700">Label Size: <span id="dataLabelSizeValue" class="text-xs">12</span></label>
                             <input type="range" id="dataLabelSizeInput" min="8" max="20" step="1" value="12" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                         </div>
                     </div>
                 </div>

                 <hr class="border-gray-200">

                 <!-- Title Group -->
                 <div id="title" class="mb-4">
                     <div>
                         <label for="chartTitleInput" class="block text-sm font-medium text-gray-700">Chart Title:</label>
                         <input type="text" id="chartTitleInput" placeholder="Enter chart title (optional)" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                     </div>
                     <!-- X-Axis Title Input -->
                     <div class="mt-3">
                         <label for="xAxisTitleInput" class="block text-sm font-medium text-gray-700">X-Axis Title:</label>
                         <input type="text" id="xAxisTitleInput" placeholder="X-Axis label (optional)" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                     </div>
                     <!-- Y-Axis Title Input -->
                     <div class="mt-3">
                         <label for="yAxisTitleInput" class="block text-sm font-medium text-gray-700">Y-Axis Title:</label>
                         <input type="text" id="yAxisTitleInput" placeholder="Y-Axis label (optional)" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                     </div>
                 </div>
                 
                 <hr class="border-gray-200">
                 
                 <!-- Legend Group -->
                 <div id="legend" class="mb-4">
                     <label for="toggleLegend" class="toggle-label text-sm text-gray-700">
                         <span>Show Legend</span>
                         <div class="toggle-switch">
                             <input type="checkbox" id="toggleLegend" checked>
                             <span class="toggle-slider"></span>
                         </div>
                     </label>
                     
                     <!-- Legend Properties -->
                     <div class="mt-3 legend-settings" id="legendSettings">
                         <label for="legendPosition" class="block mb-1 text-sm font-medium text-gray-700">Position:</label>
                         <select id="legendPosition" class="block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm mb-3">
                             <option value="top" selected>Top</option>
                             <option value="left">Left</option>
                             <option value="right">Right</option>
                             <option value="bottom">Bottom</option>
                         </select>
                         
                         <!-- Legend Item Sizing -->
                         <div class="grid grid-cols-2 gap-2 mb-3">
                             <div>
                                 <label for="legendBoxWidth" class="block mb-1 text-xs font-medium text-gray-700">Box Width: <span id="legendBoxWidthValue">15</span>px</label>
                                 <input type="range" id="legendBoxWidth" min="8" max="30" value="15" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                             </div>
                             <div>
                                 <label for="legendBoxHeight" class="block mb-1 text-xs font-medium text-gray-700">Box Height: <span id="legendBoxHeightValue">15</span>px</label>
                                 <input type="range" id="legendBoxHeight" min="8" max="30" value="15" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                             </div>
                         </div>
                         
                         <!-- Spacing Controls -->
                         <div class="grid grid-cols-2 gap-2 mb-3">
                             <div>
                                 <label for="legendItemSpacing" class="block mb-1 text-xs font-medium text-gray-700">Item Gap: <span id="legendItemSpacingValue">10</span>px</label>
                                 <input type="range" id="legendItemSpacing" min="0" max="30" value="10" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                             </div>
                             <div>
                                 <label for="legendPadding" class="block mb-1 text-xs font-medium text-gray-700">Padding: <span id="legendPaddingValue">10</span>px</label>
                                 <input type="range" id="legendPadding" min="0" max="30" value="10" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                             </div>
                         </div>
                         
                         <!-- Legend Margin -->
                         <div class="mb-3">
                             <label for="legendMargin" class="block mb-1 text-xs font-medium text-gray-700">Chart Margin: <span id="legendMarginValue">20</span>px</label>
                             <input type="range" id="legendMargin" min="0" max="50" value="20" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                         </div>
                         
                         <!-- Legend Text Size -->
                         <label for="legendTextSize" class="block mb-1 text-sm font-medium text-gray-700">Text Size: <span id="legendTextSizeValue">12</span>px</label>
                         <input type="range" id="legendTextSize" min="8" max="20" value="12" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                     </div>
                 </div>
            </div>
             

             <div class="mt-6 border-t border-gray-200 pt-4">
                <h3 class="text-md font-medium text-gray-800 mb-3">Color Settings</h3>
                
                <!-- Chart Background and Text Color Group -->
                <div class="mb-4 pb-4 border-b border-gray-200">
                    
                    <!-- Chart Background Color -->
                    <div class="mb-3">
                        <div class="flex items-center">
                            <label class="toggle-label text-sm text-gray-700" for="chartBackgroundToggle">
                                <span>Dark Background</span>
                                <div class="toggle-switch">
                                    <input type="checkbox" id="chartBackgroundToggle">
                                    <span class="toggle-slider"></span>
                                </div>
                            </label>
                        </div>
                    </div>
                    
                    <!-- Chart Text Color -->
                    <div class="mb-2">
                        <label for="chartTextColor" class="block mb-1 text-sm font-medium text-gray-700">Text:</label>
                        <div class="flex items-center">
                            <input type="color" id="chartTextColor" value="#333333" class="h-8 w-10 p-0 border border-gray-300 rounded cursor-pointer">
                            <button id="resetTextColorBtn" class="ml-2 px-2 py-1 text-xs border border-gray-300 rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none">
                                Reset
                            </button>
                            <span class="ml-2 text-xs text-gray-500">Choose chart text color</span>
                        </div>
                    </div>
                </div>
                
                <!-- Color Palette -->
                <div class="mb-4">
                    <label for="colorPaletteSelect" class="block mb-1 text-sm font-medium text-gray-700">Data Series Palette:</label>
                    <select id="colorPaletteSelect" disabled class="block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                        <option value="0" selected>Default (Animoca)</option>
                        <option value="1">Blues 6</option>
                        <option value="2">Blues 5</option>
                        <option value="3">Blues 4</option>
                        <option value="4">Blues 3</option>
                        <option value="5">Blues 2</option>
                        <option value="6">Single Blue</option>
                    </select>
                </div>

             <div id="colorOverrideSection" class="mt-6 border-t border-gray-200 pt-4 hidden">
                            <h3 class="block mb-4 text-md font-medium text-gray-800">Assign Colors to Series</h3>
                            <p class="text-xs text-gray-500 mb-3">Optionally assign specific colors from the selected palette to individual series or segments.</p>
                            <div id="colorAssignmentContainer" class="grid grid-cols-1 gap-y-2 mt-4">
                                <!-- Color assignment controls will be added here dynamically -->
                     </div>
             </div>
             
             <div class="mt-6 border-t border-gray-200 pt-4">
                <h3 class="text-md font-medium text-gray-800 mb-3">Download</h3>
                <p class="text-sm text-gray-500 mb-3">Download the generated chart as a PNG image (transparent background).</p>
                <button id="downloadBtn" disabled class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-md shadow transition duration-150 ease-in-out disabled:bg-gray-400">
                    Download Chart (PNG)
                </button>
             </div>
        </div>
                </div>
            </div>

            <!-- Resize Handle -->
            <div class="resize-handle" id="resizeHandle"></div>
            
            <!-- Right Panel - Data Preview & Chart -->
            <div class="right-panel">
                <!-- Data Preview -->
                <div id="dataTableContainer" class="hidden">
                    <div class="flex justify-between items-center mb-2">
                        <h3 class="panel-title mb-0">Data Preview</h3>
                        <span id="csvFilename" class="text-xs text-gray-500"></span>
                    </div>
                    <div class="data-table-scroll-container overflow-y-auto max-h-[200px] border border-gray-200 rounded-lg shadow-sm">
                        <div class="overflow-x-auto relative">
                            <table id="dataTable" class="min-w-full divide-y divide-gray-200 border-collapse">
                                <thead class="bg-gray-50"></thead>
                                <tbody class="bg-white divide-y divide-gray-200"></tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <!-- Chart Preview -->
                <div>
                    <div class="flex justify-between items-center mb-3">
                        <h3 class="panel-title mb-0">Chart Preview</h3>
                        <div class="flex items-center space-x-2">
                            <div class="flex items-center space-x-1">
                                <input type="number" id="chartWidthInput" min="300" max="5000" value="1280" 
                                    class="w-16 h-8 text-xs rounded border border-gray-300 px-1">
                                <span class="text-xs text-gray-500">Ã—</span>
                                <input type="number" id="chartHeightInput" min="200" max="10000" value="720" 
                                    class="w-16 h-8 text-xs rounded border border-gray-300 px-1">
                            </div>
                            <div class="text-xs flex items-center space-x-2">
                                <label for="maintainAspectRatio" class="toggle-label text-xs text-gray-500 whitespace-nowrap">
                                    <span>Ratio</span>
                                    <div class="toggle-switch toggle-switch-sm">
                                        <input type="checkbox" id="maintainAspectRatio" checked>
                                        <span class="toggle-slider"></span>
                                    </div>
                                </label>
                                <!-- Hide the scale to fit toggle since it's disabled -->
                                <label for="previewModeToggle" class="toggle-label text-xs text-gray-500 whitespace-nowrap hidden" title="Scale to fit is disabled">
                                    <span>Scale to fit</span>
                                    <div class="toggle-switch toggle-switch-sm">
                                        <input type="checkbox" id="previewModeToggle">
                                        <span class="toggle-slider"></span>
                                    </div>
                                </label>
                                <div class="flex items-center space-x-2">
                                    <button id="resetDimensionsBtn" class="px-2 py-1 text-xs border border-gray-300 rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none">
                                        Reset
                                    </button>
                                    <button id="applyDimensionsBtn" class="px-2 py-1 text-xs border border-blue-500 rounded-md text-white bg-blue-500 hover:bg-blue-600 focus:outline-none">
                                        Apply
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="chartContainer">
                        <div id="chartWrapper">
                            <canvas id="myChart"></canvas>
                        </div>
                        <div id="previewModeIndicator" class="preview-mode-indicator hidden" title="This mode scales the chart to fit in the viewport while maintaining the specified dimensions for download. Toggle Preview mode to see the chart at its actual size.">
                            Scale to fit (Actual: <span id="actualDimensions"></span>)
                        </div>
                        <p id="chartPlaceholder" class="absolute inset-0 flex items-center justify-center text-gray-500 text-center p-4">Upload a CSV file to generate the chart.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Set Chart.js Global Font ---
        Chart.defaults.font.family = "'Inter', sans-serif";
        Chart.defaults.font.size = 12;

        // --- Define White Background Plugin ---
        const whiteBackgroundPlugin = { 
            id: 'whiteBackground', 
            beforeDraw: (chart, args, options) => { 
                // Skip if explicitly disabled
                if (options.enable === false) return;
                
                const {ctx, width, height} = chart; 
                ctx.save(); 
                // Use dark background (#3C4A57) when toggle is checked, otherwise white
                const bgColor = chartBackgroundToggle && chartBackgroundToggle.checked ? '#3C4A57' : '#ffffff';
                ctx.fillStyle = bgColor; 
                ctx.fillRect(0, 0, width, height); 
                ctx.restore(); 
            } 
        };

        // --- Register Plugins ---
        if (window.ChartjsPluginStacked100) {
            try { Chart.register(ChartjsPluginStacked100.default); console.log("ChartjsPluginStacked100 registered successfully."); }
            catch (e) { console.error("Error registering ChartjsPluginStacked100:", e); }
        } else { console.warn("ChartjsPluginStacked100 not found. Stacked 100% chart may not work."); }

        // Register the datalabels plugin
        if (window.ChartDataLabels) {
            try { Chart.register(ChartDataLabels); console.log("ChartDataLabels plugin registered successfully."); }
            catch (e) { console.error("Error registering ChartDataLabels plugin:", e); }
        } else { console.warn("ChartDataLabels plugin not found. Data labels may not work."); }

        // Custom plugin to add margin between legend and chart
        const legendMarginPlugin = {
            id: 'legendMargin',
            beforeInit(chart) {
                // Get reference to the original fit function
                const originalFit = chart.legend.fit;
                
                // Override the fit function
                chart.legend.fit = function fit() {
                    // Call original function and bind scope
                    originalFit.bind(chart.legend)();
                    
                    // Add extra height for margin between legend and chart
                    // Use the value from the UI slider, or default to 20px if not available
                    const marginValue = legendMargin ? parseInt(legendMargin.value, 10) : 20;
                    this.height += marginValue;
                }
            }
        };

        // Register the custom plugin
        Chart.register(legendMarginPlugin);

        // --- DOM Elements ---
        const csvFileInput = document.getElementById('csvFile');
        const downloadBtn = document.getElementById('downloadBtn');
        const chartContainer = document.getElementById('chartContainer');
        const chartCanvas = document.getElementById('myChart');
        const messageArea = document.getElementById('messageArea');
        const statusMessageArea = document.getElementById('statusMessageArea');
        const chartPlaceholder = document.getElementById('chartPlaceholder');
        const configSection = document.getElementById('configSection');
        const chartTypeSelect = document.getElementById('chartTypeSelect');
        const barSettingsDiv = document.getElementById('barSettings');
        const barPercentageInput = document.getElementById('barPercentageInput');
        const categoryPercentageInput = document.getElementById('categoryPercentageInput');
        const barPercValueSpan = document.getElementById('barPercValue');
        const catPercValueSpan = document.getElementById('catPercValue');
        const dataTableContainer = document.getElementById('dataTableContainer');
        const dataTableHead = document.querySelector('#dataTable thead');
        const dataTableBody = document.querySelector('#dataTable tbody');
        const toggleTransposeCheckbox = document.getElementById('toggleTranspose');
        const toggleDatesCheckbox = null; // Removed dates functionality
        const toggleUseFirstRowAsHeadersCheckbox = document.getElementById('toggleUseFirstRowAsHeaders');
        const toggleUseFirstRowAsHeadersLabel = document.getElementById('toggleUseFirstRowAsHeadersLabel');
        const useHeadersToggleText = document.getElementById('useHeadersToggleText');
        const dateFormatContainer = null; // Removed dates functionality
        const dateFormatInput = null; // Removed dates functionality
        const toggleDataLabelsCheckbox = document.getElementById('toggleDataLabels');
        const lineSettingsDiv = document.getElementById('lineSettings');
        const toggleCurvedLinesCheckbox = document.getElementById('toggleCurvedLines');
        const lineTensionInput = document.getElementById('lineTensionInput');
        const lineTensionValueSpan = document.getElementById('lineTensionValue');
        const curveSettingsContainer = document.getElementById('curveSettingsContainer');
        const innerRadiusInput = document.getElementById('innerRadiusInput');
        const dataLabelSizeInput = document.getElementById('dataLabelSizeInput');
        const innerRadiusValueSpan = document.getElementById('innerRadiusValue');
        const dataLabelSizeValueSpan = document.getElementById('dataLabelSizeValue');
        const doughnutSettingsDiv = document.getElementById('doughnutSettings');
        const pieChartSettingsDiv = document.getElementById('pieChartSettings');
        const chartTitleInput = document.getElementById('chartTitleInput');
        const xAxisTitleInput = document.getElementById('xAxisTitleInput');
        const yAxisTitleInput = document.getElementById('yAxisTitleInput');
        const toggleLegendCheckbox = document.getElementById('toggleLegend');
        const legendPosition = document.getElementById('legendPosition');
        const legendBoxWidth = document.getElementById('legendBoxWidth');
        const legendBoxHeight = document.getElementById('legendBoxHeight');
        const legendBoxWidthValue = document.getElementById('legendBoxWidthValue');
        const legendBoxHeightValue = document.getElementById('legendBoxHeightValue');
        const legendItemSpacing = document.getElementById('legendItemSpacing');
        const legendItemSpacingValue = document.getElementById('legendItemSpacingValue');
        const legendPadding = document.getElementById('legendPadding');
        const legendPaddingValue = document.getElementById('legendPaddingValue');
        const legendTextSize = document.getElementById('legendTextSize');
        const legendTextSizeValue = document.getElementById('legendTextSizeValue');
        const legendMargin = document.getElementById('legendMargin');
        const legendMarginValue = document.getElementById('legendMarginValue');
        const legendSettings = document.getElementById('legendSettings');
        // Removed applyChartSettingsBtn
        const dropZone = document.getElementById('dropZone');
        const downloadSampleBtn = document.getElementById('downloadSampleBtn');
        const colorPaletteSelect = document.getElementById('colorPaletteSelect');
        const colorOverrideSection = document.getElementById('colorOverrideSection');
        const colorAssignmentContainer = document.getElementById('colorAssignmentContainer');
        const csvFilenameDisplay = document.getElementById('csvFilename');
        const chartBackgroundToggle = document.getElementById('chartBackgroundToggle');
        const chartTextColorPicker = document.getElementById('chartTextColor');
        const resetTextColorBtn = document.getElementById('resetTextColorBtn');
        const lineWidthInput = document.getElementById('lineWidthInput');
        const lineWidthValueSpan = document.getElementById('lineWidthValue');

        // Chart Dimension Elements
        const chartWrapper = document.getElementById('chartWrapper');
        const chartWidthInput = document.getElementById('chartWidthInput');
        const chartHeightInput = document.getElementById('chartHeightInput');
        const maintainAspectRatioCheckbox = document.getElementById('maintainAspectRatio');
        const previewModeToggle = document.getElementById('previewModeToggle');
        const previewModeIndicator = document.getElementById('previewModeIndicator');
        const actualDimensions = document.getElementById('actualDimensions');
        const resetDimensionsBtn = document.getElementById('resetDimensionsBtn');

        // --- Global Variables ---
        let chartInstance = null;
        let originalHeaders = [];
        let originalFirstRowDataObject = null;
        let parsedRawData = [];
        let isTransposed = false;
        let useFirstRowAsHeaders = true;
        let treatFirstColAsDates = false; // Always false since we removed the date functionality
        let dateFormat = 'YYYY-MM-DD'; // Keep for compatibility but not used
        let currentChartData = { labels: [], datasets: [] };
        let currentChartOptions = {};

        // --- Chart Dimension Variables ---
        let chartWidth = 1280;
        let chartHeight = 720;
        let aspectRatio = chartWidth / chartHeight;
        let maintainAspectRatio = true;
        let previewModeEnabled = false; // Scale to fit is now disabled by default

        // --- Default values ---
        const DOWNLOAD_WIDTH = 1280;
        const DOWNLOAD_HEIGHT = 720;
        const DEFAULT_CHART_WIDTH = 1280;
        const DEFAULT_CHART_HEIGHT = 720;
        const DEFAULT_BAR_PERC = 1;
        const DEFAULT_CAT_PERC = 0.8;
        const DEFAULT_INNER_RADIUS = 50;
        const DEFAULT_LABEL_SIZE = 12;
        const DEFAULT_LINE_WIDTH = 2;

        // --- Color Palettes ---
        function hexToRgb(hex) { let r = 0, g = 0, b = 0; if (hex.length == 4) { r = parseInt(hex[1] + hex[1], 16); g = parseInt(hex[2] + hex[2], 16); b = parseInt(hex[3] + hex[3], 16); } else if (hex.length == 7) { r = parseInt(hex[1] + hex[2], 16); g = parseInt(hex[3] + hex[4], 16); b = parseInt(hex[5] + hex[6], 16); } return { r, g, b }; }
        function createPalette(hexColors) { const bg = hexColors.map(hex => { const {r, g, b} = hexToRgb(hex); return `rgb(${r}, ${g}, ${b})`; }); const border = bg; return { bg, border }; }
        const PALETTES = [ createPalette(['#12ACEC', '#DF301C', '#FFB042', '#98D460', '#164CD3', '#EA8C69', '#C466E4', '#E8C99E', '#C86952', '#35B3B3', '#6D64E9']), createPalette(['#12ACEC', '#475569', '#64748B', '#94A3B8', '#CBD5E1', '#E2E8F0']), createPalette(['#12ACEC', '#64748B', '#94A3B8', '#CBD5E1', '#E2E8F0']), createPalette(['#12ACEC', '#94A3B8', '#CBD5E1', '#E2E8F0']), createPalette(['#12ACEC', '#CBD5E1', '#E2E8F0']), createPalette(['#12ACEC', '#CBD5E1']), createPalette(['#12ACEC']) ];
        function rgbToHex(rgbString) { if (!rgbString || typeof rgbString !== 'string') return '#000000'; const match = rgbString.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*[\d.]+\)?)$/); if (!match) { /* Check for hex already */ if (/^#[0-9A-F]{6}$/i.test(rgbString)) return rgbString; return '#000000'; } const r = parseInt(match[1], 10); const g = parseInt(match[2], 10); const b = parseInt(match[3], 10); return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase(); }
        // Helper to get contrasting text color (black/white) for a background color
        function getContrastYIQ(rgbColor) {
            try {
                const match = rgbColor.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*[\d.]+)?\)$/);
                if (!match) return '#000'; // Default to black if parse fails
                const r = parseInt(match[1], 10);
                const g = parseInt(match[2], 10);
                const b = parseInt(match[3], 10);
                const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
                return (yiq >= 128) ? '#000' : '#FFF';
            } catch (e) {
                return '#000'; // Default to black on error
            }
        }


        // --- Functions ---
        function showError(message) { /* ... */ messageArea.textContent = message; messageArea.classList.remove('hidden'); statusMessageArea.classList.add('hidden'); }
        function showStatus(message) { /* ... */ statusMessageArea.textContent = message; statusMessageArea.classList.remove('hidden'); messageArea.classList.add('hidden'); }
        function hideMessages() { /* ... */ messageArea.classList.add('hidden'); statusMessageArea.classList.add('hidden'); }
        function resetUI() {
            // Reset chart type
            document.getElementById('chartTypeSelect').value = 'bar';
            
            // Reset color palette
            document.getElementById('colorPaletteSelect').value = '0';
            
            // Reset color pickers to defaults
            if (chartBackgroundToggle) chartBackgroundToggle.checked = false;
            if (chartTextColorPicker) chartTextColorPicker.value = '#333333';
            
            // Clear color assignments & hide color override section
            document.getElementById('colorAssignmentContainer').innerHTML = '';
            document.getElementById('colorOverrideSection').classList.add('hidden');
            
            // Reset dimensions
            document.getElementById('chartWidthInput').value = '800';
            document.getElementById('chartHeightInput').value = '500';
            
            if (configSection) configSection.classList.add('hidden');
            if (dataTableContainer) dataTableContainer.classList.add('hidden');
            // Clear color assignments
            if (colorAssignmentContainer) colorAssignmentContainer.innerHTML = '';
            if (dataTableHead) dataTableHead.innerHTML = '';
            if (dataTableBody) dataTableBody.innerHTML = '';
            // Clear CSV filename display
            if (csvFilenameDisplay) csvFilenameDisplay.textContent = '';
            
            if (chartTypeSelect) chartTypeSelect.value = 'column';
            if (colorPaletteSelect) colorPaletteSelect.value = '0';
            
            // Reset bar and category percentage settings
            if (barPercentageInput) barPercentageInput.value = DEFAULT_BAR_PERC;
            if (categoryPercentageInput) categoryPercentageInput.value = DEFAULT_CAT_PERC;
            if (barPercValueSpan) barPercValueSpan.textContent = DEFAULT_BAR_PERC;
            if (catPercValueSpan) catPercValueSpan.textContent = DEFAULT_CAT_PERC;
            
            // Reset line settings
            if (toggleCurvedLinesCheckbox) toggleCurvedLinesCheckbox.checked = false;
            if (lineTensionInput) lineTensionInput.value = 0.4;
            if (lineTensionValueSpan) lineTensionValueSpan.textContent = '0.4';
            
            // Reset doughnut settings
            if (innerRadiusInput) innerRadiusInput.value = DEFAULT_INNER_RADIUS;
            if (innerRadiusValueSpan) innerRadiusValueSpan.textContent = DEFAULT_INNER_RADIUS;
            
            // Reset pie chart settings
            if (toggleDataLabelsCheckbox) toggleDataLabelsCheckbox.checked = true;
            if (dataLabelSizeInput) dataLabelSizeInput.value = DEFAULT_LABEL_SIZE;
            if (dataLabelSizeValueSpan) dataLabelSizeValueSpan.textContent = DEFAULT_LABEL_SIZE;
            
            // Hide chart-specific settings divs - they will be shown based on chart type by toggleChartSettingsVisibility
            if (doughnutSettingsDiv) doughnutSettingsDiv.classList.add('hidden');
            if (pieChartSettingsDiv) pieChartSettingsDiv.classList.add('hidden');
            if (lineSettingsDiv) lineSettingsDiv.classList.add('hidden');
            
            if (chartTypeSelect) chartTypeSelect.disabled = true;
            if (colorPaletteSelect) colorPaletteSelect.disabled = true;
            if (downloadBtn) downloadBtn.disabled = true;
            
            if (toggleUseFirstRowAsHeadersCheckbox) toggleUseFirstRowAsHeadersCheckbox.checked = true; // Default to using headers
            if (chartTitleInput) chartTitleInput.value = '';
            if (xAxisTitleInput) xAxisTitleInput.value = '';
            if (yAxisTitleInput) yAxisTitleInput.value = '';
            
            // Update the toggle text based on transpose state
            updateHeaderToggleText();
            
            // Reset chart dimensions
            if (chartWidthInput) chartWidthInput.value = DEFAULT_CHART_WIDTH;
            if (chartHeightInput) chartHeightInput.value = DEFAULT_CHART_HEIGHT;
            if (maintainAspectRatioCheckbox) maintainAspectRatioCheckbox.checked = true;
            if (previewModeToggle) previewModeToggle.checked = true;
            if (toggleLegendCheckbox) toggleLegendCheckbox.checked = true;
            
            // Initialize legend settings
            if (legendPosition) legendPosition.value = 'top';
            if (legendBoxWidth) legendBoxWidth.value = 15;
            if (legendBoxWidthValue) legendBoxWidthValue.textContent = 15;
            if (legendBoxHeight) legendBoxHeight.value = 15;
            if (legendBoxHeightValue) legendBoxHeightValue.textContent = 15;
            if (legendItemSpacing) legendItemSpacing.value = 10;
            if (legendItemSpacingValue) legendItemSpacingValue.textContent = 10;
            if (legendPadding) legendPadding.value = 10;
            if (legendPaddingValue) legendPaddingValue.textContent = 10;
            if (legendTextSize) legendTextSize.value = 12;
            if (legendTextSizeValue) legendTextSizeValue.textContent = 12;
            if (legendMargin) legendMargin.value = 20;
            if (legendMarginValue) legendMarginValue.textContent = 20;
            if (legendSettings && toggleLegendCheckbox) {
                legendSettings.style.display = toggleLegendCheckbox.checked ? 'block' : 'none';
            }
            
            chartWidth = DEFAULT_CHART_WIDTH;
            chartHeight = DEFAULT_CHART_HEIGHT;
            aspectRatio = chartWidth / chartHeight;
            previewModeEnabled = true;
            
            if (previewModeIndicator) {
                previewModeIndicator.classList.add('hidden');
            }
            
            if (chartInstance) { chartInstance.destroy(); chartInstance = null; }
            if (chartPlaceholder) chartPlaceholder.classList.remove('hidden');
            
            const ctx = chartCanvas ? chartCanvas.getContext('2d') : null;
            if (ctx) { ctx.clearRect(0, 0, chartCanvas.width, chartCanvas.height); }
            
            if (chartCanvas) {
                chartCanvas.style.width = null;
                chartCanvas.style.height = null;
            }
            
            originalHeaders = [];
            parsedRawData = [];
            originalFirstRowDataObject = null;
            isTransposed = toggleTransposeCheckbox ? toggleTransposeCheckbox.checked : false;
            useFirstRowAsHeaders = toggleUseFirstRowAsHeadersCheckbox ? toggleUseFirstRowAsHeadersCheckbox.checked : true;
            treatFirstColAsDates = toggleDatesCheckbox ? toggleDatesCheckbox.checked : false;
            currentChartData = { labels: [], datasets: [] };
            currentChartOptions = {};
            
            hideMessages();
        }
        function isNumeric(value) { /* ... */ if (typeof value === 'number' && !isNaN(value)) return true; if (typeof value !== 'string') return false; if (value.trim() === '' || value === null) return false; const cleanedVal = value.replace(/,/g, ''); return !isNaN(parseFloat(cleanedVal)) && isFinite(cleanedVal.trim() === '' ? NaN : cleanedVal); }
        function parseNumericValue(value) { /* ... */ if (typeof value === 'number' && !isNaN(value)) return value; if (typeof value !== 'string') return null; const cleanedVal = value.replace(/,/g, ''); const num = parseFloat(cleanedVal); return isNaN(num) ? null : num; }
        function analyzeData(data, currentHeaders, transposeEnabled, parseDates, dtFormat) {
            const headersWereUsed = true;
            const useColAForLabels = !transposeEnabled;
            
            console.log("Analyzing data. transposeEnabled:", transposeEnabled, "useFirstRowAsHeaders:", useFirstRowAsHeaders, "parseDates:", parseDates);
            
            if (!currentHeaders || currentHeaders.length < 2 || !data || data.length === 0) {
                showError("CSV must contain at least two columns (Label/Date, Value).");
                return null;
            }
            
            let labels = [];
            let datasets = [];
            const baseFontSize = Chart.defaults.font.size || 12;
            
            if (!transposeEnabled) {
                console.log("Analyzing in standard orientation");
                
                // First column (index '0') is used for labels/dates
                const labelHeaderKey = '0';
                
                showStatus(`Analyzing data... Using first column as Label/Date column.`);
                
                // Get labels from the first column
                if (parseDates) {
                    labels = data.map(row => {
                        const dateStr = String(row[labelHeaderKey] ?? '');
                        const dateObj = moment(dateStr, dtFormat);
                        return dateObj.isValid() ? dateObj.toDate() : dateStr;
                    });
                    
                    if (labels.some(l => typeof l === 'string')) {
                        showError("Warning: Some values in the first column could not be parsed as dates using the format: " + dtFormat);
                    }
                } else {
                    labels = data.map(row => String(row[labelHeaderKey] ?? ''));
                }
                
                // If using first row as headers, don't include it in the data labels
                if (useFirstRowAsHeaders) {
                    // Skip the first label which is a header
                    labels = labels.slice(1);
                    console.log("Using first row as headers, skipping in labels array");
                }
                
                console.log("Generated labels:", labels.slice(0, 5));
                
                // Process remaining columns as data series
                // Skip the first column (index '0') which contains labels
                const dataColumnIndices = currentHeaders.slice(1);
                
                
                dataColumnIndices.forEach((columnIndex) => {
                    let values = data.map(row => row[columnIndex]);
                    let numericCount = 0;
                    const sampleSize = Math.min(values.length, 10);
                    
                    // Check if most values are numeric
                    if (sampleSize > 0) {
                        for (let i = 0; i < sampleSize; i++) {
                            if (isNumeric(values[i])) {
                                numericCount++;
                            }
                        }
                    }
                    
                    const isColNumeric = sampleSize === 0 || (numericCount / sampleSize) > 0.5;
                    
                    if (isColNumeric) {
                        const numericColumnData = values.map(val => parseNumericValue(val));
                        const containsNumbers = numericColumnData.some(val => val !== null);
                        
                        if (containsNumbers) {
                            // Use the appropriate source for the series label based on useFirstRowAsHeaders setting
                            let seriesLabel;
                            if (useFirstRowAsHeaders && data.length > 0) {
                                seriesLabel = String(data[0][columnIndex] ?? `Column ${parseInt(columnIndex) + 1}`);
                            } else {
                                seriesLabel = `Column ${parseInt(columnIndex) + 1}`;
                            }
                            
                            // Determine if we should include the first row as data or treat it as header
                            let dataToUse = numericColumnData;
                            
                            // If using first row as headers, skip that row in the dataset
                            if (useFirstRowAsHeaders) {
                                dataToUse = numericColumnData.slice(1); // Skip the first row (header row)
                            }
                            
                            datasets.push({
                                label: seriesLabel,
                                data: dataToUse,
                                borderWidth: 0
                            });
                        } else {
                            console.log(`Column with index '${columnIndex}' skipped (no numeric values found).`);
                        }
                    } else {
                        console.log(`Column with index '${columnIndex}' skipped (not numeric).`);
                    }
                });
            } else {
                showStatus("Analyzing transposed data... Rows become series.");
                
                // When transposed, category headers are all columns except the first
                let categoryHeaderIndices = currentHeaders.slice(1);
                const seriesLabelHeaderKey = '0';
                
                // Get series labels from the first column
                let seriesLabelsSource = data.map(row => String(row[seriesLabelHeaderKey] ?? ''));
                
                // Create data matrix - each row becomes a series
                let dataMatrix = data.map(row => 
                    categoryHeaderIndices.map(columnIndex => parseNumericValue(row[columnIndex]))
                );
                
                console.log("Transposed - Categories:", categoryHeaderIndices.slice(0,5));
                console.log("Series Labels Source:", seriesLabelsSource.slice(0,5));
                
                // Handle column headers for transposed data
                if (useFirstRowAsHeaders && data.length > 0) {
                    // Use first row values as category labels
                    labels = categoryHeaderIndices.map(columnIndex => 
                        String(data[0][columnIndex] ?? `Column ${parseInt(columnIndex) + 1}`)
                    );
                    
                    // Skip the first row in data matrix as it's used for headers
                    dataMatrix = dataMatrix.slice(1);
                    seriesLabelsSource = seriesLabelsSource.slice(1);
                } else {
                    // Don't use first row as headers, just use generic column labels
                    labels = categoryHeaderIndices.map(columnIndex => `Column ${parseInt(columnIndex) + 1}`);
                }
                
                // Create datasets from rows
                dataMatrix.forEach((rowData, rowIndex) => {
                    if (rowData.some(val => val !== null)) {
                        datasets.push({
                            label: seriesLabelsSource[rowIndex] || `Series ${rowIndex + 1}`,
                            data: rowData,
                            borderWidth: 0
                        });
                    } else {
                        console.log(`Original Row ${rowIndex + 1} skipped (no numeric values).`);
                    }
                });
                
                console.log(`Created ${datasets.length} datasets in transposed mode.`);
            }
            
            if (datasets.length === 0) {
                showError("No valid numeric data series found.");
                return null;
            }
            
            showStatus(`Found ${datasets.length} numeric data series. Preparing chart data...`);
            currentChartData = { labels, datasets };
            return currentChartData;
        }
        // Removed applyChartSettings function
        function getColumnLetter(index) { /* ... */ let letter = ''; let tempIndex = index; while (tempIndex >= 0) { letter = String.fromCharCode((tempIndex % 26) + 65) + letter; tempIndex = Math.floor(tempIndex / 26) - 1; } return letter; }
        function transposeData(data, headers) {
            console.log("Transposing data (using numeric indices)...");
            if (!data || data.length === 0 || !headers || headers.length < 2) return { transposedData: [], transposedHeaders: [] };

            // First column index is '0', all others are for categories/values
            const categoryIndices = headers.slice(1);
            const seriesLabelIndex = '0';
            
            // Get values from first column to use as column headers in transposed data
            const rowLabels = data.map(row => String(row[seriesLabelIndex] ?? ''));
            
            // Create new headers array with numeric indices
            const transposedHeaders = Array.from({ length: rowLabels.length + 1 }, (_, i) => i.toString());
            
            console.log("Transposed headers will be numeric indices:", transposedHeaders.slice(0, 5));
            
            // Create transposed data rows - one row per original column (except first)
            const transposedData = categoryIndices.map((categoryIndex, catIdx) => {
                // Create a row object with numeric indices as keys
                const newRow = {};
                
                // First cell (index '0') contains the category value from first row
                newRow['0'] = data.length > 0 ? data[0][categoryIndex] : `Column ${catIdx + 1}`;
                
                // Add remaining cells - one per original row
                data.forEach((originalRow, rowIdx) => {
                    // +1 because index 0 is reserved for the category label
                    const targetIndex = (rowIdx + 1).toString();
                    newRow[targetIndex] = originalRow[categoryIndex];
                });
                
                return newRow;
            });
            
            console.log("Transposed data sample:", transposedData.slice(0, 3));
            return { transposedData, transposedHeaders };
        }
        function displayDataTable(displayHeaders, tableData, dataUsesHeaders, headerRowObj) {
            if (!dataTableHead || !dataTableBody || !displayHeaders) return;
            
            console.log("Displaying table. Headers:", displayHeaders);
            dataTableHead.innerHTML = '';
            dataTableBody.innerHTML = '';

            // --- Create Table Header (A, B, C...) ---
            const theadRow = document.createElement('tr');
            const thNum = document.createElement('th');
            thNum.scope = 'col';
            thNum.className = 'px-3 py-2 text-center text-xs font-medium text-gray-500 uppercase tracking-wider';
            thNum.textContent = '#';
            theadRow.appendChild(thNum);

            // Add column headers (A, B, C...)
            const numColumns = displayHeaders.length;
            for (let i = 0; i < numColumns; i++) {
                const th = document.createElement('th');
                th.scope = 'col';
                th.className = 'px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider';
                th.textContent = getColumnLetter(i);
                theadRow.appendChild(th);
            }
            dataTableHead.appendChild(theadRow);

            // --- Create Table Body ---
            let rowNumber = 1;

            // Add data rows directly
            console.log("Displaying data rows count:", tableData.length);
            tableData.forEach((rowData, rowIndex) => {
                const tr = document.createElement('tr');
                const thRowNum = document.createElement('th');
                thRowNum.scope = 'row';
                thRowNum.className = 'px-3 py-2 whitespace-nowrap text-sm text-gray-500 text-center';
                thRowNum.textContent = rowNumber++;
                tr.appendChild(thRowNum);

                // Add data cells for this row
                displayHeaders.forEach((header, colIndex) => {
                    const td = document.createElement('td');
                    td.className = 'px-3 py-2 whitespace-nowrap text-sm text-gray-700';
                    
                    if (colIndex === 0) {
                        // First column is always the label/category
                        td.className += ' font-medium'; // Make label column bold
                    }
                    
                    const cellData = dataUsesHeaders ? rowData[header] : rowData[colIndex];
                    td.textContent = cellData ?? '';
                    td.contentEditable = 'true'; // Make the cell editable
                    td.dataset.rowIndex = rowIndex;
                    td.dataset.colIndex = colIndex;
                    td.dataset.header = header;
                    
                    // Add event listener for data changes
                    td.addEventListener('blur', function() {
                        const newValue = this.textContent.trim();
                        const rowIdx = parseInt(this.dataset.rowIndex);
                        const colIdx = parseInt(this.dataset.colIndex);
                        const headerKey = this.dataset.header;
                        
                        // Update the data
                        if (dataUsesHeaders) {
                            tableData[rowIdx][headerKey] = isNumeric(newValue) ? parseNumericValue(newValue) : newValue;
                        } else {
                            tableData[rowIdx][colIdx] = isNumeric(newValue) ? parseNumericValue(newValue) : newValue;
                        }
                        
                        updateChartFromCellEdit(rowIdx, colIdx, headerKey, newValue);
                        console.log(`Updated data at [${rowIdx}, ${colIdx}] to ${newValue}`);
                    });
                    
                    // Add input event for real-time updates while typing
                    td.addEventListener('input', function() {
                        const newValue = this.textContent.trim();
                        const rowIdx = parseInt(this.dataset.rowIndex);
                        const colIdx = parseInt(this.dataset.colIndex);
                        const headerKey = this.dataset.header;
                        
                        // Skip first column (labels) for instant updates
                        if (colIdx > 0) {
                            // Update the data
                            if (dataUsesHeaders) {
                                tableData[rowIdx][headerKey] = isNumeric(newValue) ? parseNumericValue(newValue) : newValue;
                            } else {
                                tableData[rowIdx][colIdx] = isNumeric(newValue) ? parseNumericValue(newValue) : newValue;
                            }
                            
                            updateChartFromCellEdit(rowIdx, colIdx, headerKey, newValue);
                            console.log(`Instant update data at [${rowIdx}, ${colIdx}] to ${newValue}`);
                        }
                    });
                    
                    // Add keydown event to handle Enter key press
                    td.addEventListener('keydown', function(e) {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            this.blur(); // Remove focus to trigger the blur event
                        }
                    });
                    
                    // Add paste event to handle clipboard data
                    td.addEventListener('paste', function(e) {
                        e.preventDefault(); // Prevent the default paste behavior
                        
                        // Get the current cell position
                        const startRowIdx = parseInt(this.dataset.rowIndex);
                        const startColIdx = parseInt(this.dataset.colIndex);
                        const startHeaderKey = this.dataset.header;
                        
                        // Get the clipboard data
                        const clipboard = e.clipboardData || window.clipboardData;
                        const pastedData = clipboard.getData('text');
                        
                        // Skip if empty
                        if (!pastedData.trim()) {
                            return;
                        }
                        
                        console.log("Pasting data:", pastedData);
                        
                        // Parse the clipboard data (split by newlines and tabs/commas)
                        const rows = pastedData.split(/[\r\n]+/).filter(row => row.trim() !== '');
                        
                        // Track if we need to update the chart
                        let needsChartUpdate = false;
                        
                        // Process each row of pasted data
                        rows.forEach((row, rowOffset) => {
                            // Skip if we've gone past the end of the table
                            if (startRowIdx + rowOffset >= tableData.length) {
                                console.warn("Paste exceeds table bounds (rows)");
                                return;
                            }
                            
                            // Split row into cells (support for both tab and comma separators)
                            const cells = row.split(/[\t,]+/);
                            
                            // Process each cell in the row
                            cells.forEach((cellValue, colOffset) => {
                                // Skip if we've gone past the end of the columns
                                if (startColIdx + colOffset >= displayHeaders.length) {
                                    console.warn("Paste exceeds table bounds (columns)");
                                    return;
                                }
                                
                                // Calculate target cell position
                                const targetRowIdx = startRowIdx + rowOffset;
                                const targetColIdx = startColIdx + colOffset;
                                const targetHeaderKey = displayHeaders[targetColIdx];
                                
                                // Find the target cell
                                const targetCell = document.querySelector(`#dataTable tbody tr:nth-child(${targetRowIdx + 1}) td:nth-child(${targetColIdx + 1})`);
                                
                                if (targetCell) {
                                    // Update the cell content
                                    targetCell.textContent = cellValue;
                                    
                                    // Update the data
                                    if (dataUsesHeaders) {
                                        tableData[targetRowIdx][targetHeaderKey] = isNumeric(cellValue) ? parseNumericValue(cellValue) : cellValue;
                                    } else {
                                        tableData[targetRowIdx][targetColIdx] = isNumeric(cellValue) ? parseNumericValue(cellValue) : cellValue;
                                    }
                                    
                                    needsChartUpdate = true;
                                }
                            });
                        });
                        
                        // Update chart after processing all pasted cells
                        if (needsChartUpdate && chartInstance) {
                            // Bulk update all chart data
                            updateChartFromTableData(tableData, displayHeaders, dataUsesHeaders);
                        }
                    });
                    
                    tr.appendChild(td);
                });
                dataTableBody.appendChild(tr);
            });
            
            // Add a note to inform users that the table is editable and supports pasting
            const noteDiv = document.createElement('div');
            noteDiv.className = 'mt-2 text-xs text-gray-500 italic';
            noteDiv.textContent = 'Note: Click on any cell to edit its value. You can also copy data from a spreadsheet and paste it into the table. The chart will update automatically.';
            dataTableContainer.appendChild(noteDiv);
            
            dataTableContainer.classList.remove('hidden');
        }

        // Function to update the chart with all table data
        function updateChartFromTableData(tableData, headers, dataUsesHeaders) {
            if (!chartInstance) return;
            
            // Clear existing chart data
            chartInstance.data.labels = [];
            chartInstance.data.datasets.forEach((dataset) => {
                dataset.data = [];
            });
            
            // Rebuild chart data from table
            if (useFirstRowAsHeaders) {
                // Skip header row, get labels from first column
                const labels = [];
                for (let i = 1; i < tableData.length; i++) {
                    const labelVal = dataUsesHeaders ? tableData[i][headers[0]] : tableData[i][0];
                    labels.push(labelVal);
                }
                chartInstance.data.labels = labels;
                
                // Get data for each dataset (column)
                for (let colIdx = 1; colIdx < headers.length; colIdx++) {
                    const datasetIndex = colIdx - 1;
                    if (datasetIndex < chartInstance.data.datasets.length) {
                        const values = [];
                        for (let rowIdx = 1; rowIdx < tableData.length; rowIdx++) {
                            const value = dataUsesHeaders ? tableData[rowIdx][headers[colIdx]] : tableData[rowIdx][colIdx];
                            values.push(isNumeric(value) ? parseNumericValue(value) : 0);
                        }
                        chartInstance.data.datasets[datasetIndex].data = values;
                    }
                }
            } else {
                // No header row, get labels from first column
                const labels = [];
                for (let i = 0; i < tableData.length; i++) {
                    const labelVal = dataUsesHeaders ? tableData[i][headers[0]] : tableData[i][0];
                    labels.push(labelVal);
                }
                chartInstance.data.labels = labels;
                
                // Get data for each dataset (column)
                for (let colIdx = 1; colIdx < headers.length; colIdx++) {
                    const datasetIndex = colIdx - 1;
                    if (datasetIndex < chartInstance.data.datasets.length) {
                        const values = [];
                        for (let rowIdx = 0; rowIdx < tableData.length; rowIdx++) {
                            const value = dataUsesHeaders ? tableData[rowIdx][headers[colIdx]] : tableData[rowIdx][colIdx];
                            values.push(isNumeric(value) ? parseNumericValue(value) : 0);
                        }
                        chartInstance.data.datasets[datasetIndex].data = values;
                    }
                }
            }
            
            // Update the chart
            chartInstance.update();
            console.log("Chart updated with pasted data");
        }

        // Add new helper function for updating chart data
        function updateChartFromCellEdit(rowIdx, colIdx, headerKey, newValue) {
            // If this is the first column, it might be a label
            if (colIdx === 0 && chartInstance && chartInstance.data.labels) {
                // Update chart labels if this is the first column
                if (useFirstRowAsHeaders && rowIdx > 0) {
                    chartInstance.data.labels[rowIdx - 1] = newValue;
                } else if (!useFirstRowAsHeaders) {
                    chartInstance.data.labels[rowIdx] = newValue;
                }
            } else if (chartInstance && chartInstance.data.datasets) {
                // Update dataset values for other columns
                if (useFirstRowAsHeaders && rowIdx > 0) {
                    const datasetIndex = colIdx - 1; // Adjust for label column
                    if (datasetIndex >= 0 && datasetIndex < chartInstance.data.datasets.length) {
                        chartInstance.data.datasets[datasetIndex].data[rowIdx - 1] = parseNumericValue(newValue);
                    }
                } else if (!useFirstRowAsHeaders) {
                    const datasetIndex = colIdx - 1; // Adjust for label column
                    if (datasetIndex >= 0 && datasetIndex < chartInstance.data.datasets.length) {
                        chartInstance.data.datasets[datasetIndex].data[rowIdx] = parseNumericValue(newValue);
                    }
                }
            }
            
            // Update the chart
            if (chartInstance) {
                chartInstance.update('none'); // Use 'none' for smoother updates without animation
            }
        }

        /**
         * Applies selected color palette to datasets. Includes opacity logic for reuse on palette 0.
         */
        function applyPalette(datasetsToUpdate) {
            const paletteIndex = parseInt(colorPaletteSelect.value, 10) || 0;
            const selectedPalette = PALETTES[paletteIndex] || PALETTES[0];
            const paletteLength = selectedPalette.bg.length;
            const chartType = chartTypeSelect.value;
            
            datasetsToUpdate.forEach((ds, i) => {
                // For pie and doughnut charts, we need to set an array of colors for the segments
                if (chartType === 'pie' || chartType === 'doughnut') {
                    // Create an array of colors for each data point
                    if (ds.data && ds.data.length > 0) {
                        const colors = [];
                        ds.data.forEach((_, j) => {
                            const colorIndex = j % paletteLength;
                            colors.push(selectedPalette.bg[colorIndex]);
                        });
                        ds.backgroundColor = colors;
                        ds.borderColor = 'transparent';
                        ds.borderWidth = 0;
                    }
                } else {
                    // Regular charts get a single color per dataset
                    const colorIndex = i % paletteLength;
                    const isReused = i >= paletteLength;
                    let bgColor = selectedPalette.bg[colorIndex];
                    let borderColor = selectedPalette.border[colorIndex];
                    
                    if (isReused && paletteIndex === 0) {
                        console.log(`Reusing color ${colorIndex} for dataset ${i} with reduced opacity (Palette 0 only).`);
                        bgColor = bgColor.replace('rgb(', 'rgba(').replace(')', ', 0.5)');
                        borderColor = borderColor.replace('rgb(', 'rgba(').replace(')', ', 0.5)');
                    } else if (isReused) {
                        console.log(`Reusing color ${colorIndex} for dataset ${i} with FULL opacity (Palette ${paletteIndex}).`);
                    }
                    
                    ds.backgroundColor = bgColor;
                    ds.borderColor = borderColor;
                    
                    // Set appropriate border width based on chart type
                    if (chartType === 'line') {
                        // Line charts need visible borders (lines)
                        const lineWidth = parseInt(lineWidthInput.value, 10) || DEFAULT_LINE_WIDTH;
                        ds.borderWidth = lineWidth;
                    } else if (chartType === 'area' || chartType === 'areaStacked') {
                        // Area charts get a thin border
                        ds.borderWidth = 1;
                    } else if (chartType === 'scatter') {
                        // Scatter charts need a border width of 1 for visibility
                        ds.borderWidth = 1;
                    } else {
                        // All other chart types can have border width 0
                        ds.borderWidth = 0;
                    }
                }
            });
            
            console.log(`Applied palette ${paletteIndex} with proper handling for chart type: ${chartType}`);
        }

        /**
         * Populates the color assignment section with dropdowns.
         */
         function populateColorSelectors(datasets) {
             colorAssignmentContainer.innerHTML = ''; // Clear previous selectors
             if (!datasets || datasets.length === 0) {
                 return;
             }

             const paletteIndex = parseInt(colorPaletteSelect.value, 10) || 0;
             const selectedPalette = PALETTES[paletteIndex] || PALETTES[0];
             const numColorsInPalette = selectedPalette.bg.length;
             const isPieOrDoughnut = chartInstance && (chartInstance.config.type === 'pie' || chartInstance.config.type === 'doughnut');

             console.log(`Populating color selectors for ${datasets.length} datasets using palette ${paletteIndex} (size ${numColorsInPalette}).`);

             // For pie/doughnut charts, we need to show color selectors for each segment
             if (isPieOrDoughnut && datasets.length > 0 && chartInstance.data.labels) {
                 const dataset = datasets[0]; // Pie/doughnut only uses the first dataset
                 const segmentLabels = chartInstance.data.labels;
                 
                 // Create a title for the section
                 const titleDiv = document.createElement('div');
                 titleDiv.className = 'mb-3 text-sm font-medium text-gray-700';
                 titleDiv.textContent = 'Assign colors to individual segments:';
                 colorAssignmentContainer.appendChild(titleDiv);
                 
                 // Create selectors for each segment
                 segmentLabels.forEach((label, segmentIndex) => {
                     const currentColor = Array.isArray(dataset.backgroundColor) ? 
                         dataset.backgroundColor[segmentIndex] : 
                         selectedPalette.bg[segmentIndex % numColorsInPalette];
                     
                     const assignmentDiv = document.createElement('div');
                     assignmentDiv.className = 'flex items-center justify-between mb-2';

                     const segmentLabel = document.createElement('label');
                     segmentLabel.textContent = `${label} (Segment ${segmentIndex + 1})`;
                     segmentLabel.className = 'text-sm text-gray-700 mr-2 truncate flex-1';
                     segmentLabel.htmlFor = `color-select-segment-${segmentIndex}`;

                     const colorSelect = document.createElement('select');
                     colorSelect.id = `color-select-segment-${segmentIndex}`;
                     colorSelect.dataset.datasetIndex = 0; // Always first dataset for pie/doughnut
                     colorSelect.dataset.segmentIndex = segmentIndex;
                     colorSelect.className = 'color-assign-select';

                     // Find current color in palette (aproximate)
                     let currentPaletteIndex = 0;
                     if (currentColor) {
                         for (let i = 0; i < numColorsInPalette; i++) {
                             if (selectedPalette.bg[i] === currentColor) {
                                 currentPaletteIndex = i;
                                 break;
                             }
                         }
                     } else {
                         currentPaletteIndex = segmentIndex % numColorsInPalette;
                     }

                     // Populate dropdown with colors from the selected palette
                     selectedPalette.bg.forEach((bgColor, colorIdx) => {
                         const option = document.createElement('option');
                         option.value = colorIdx;
                         option.style.backgroundColor = bgColor;
                         option.style.color = getContrastYIQ(bgColor);
                         option.innerHTML = `<span class="color-assign-option-color" style="background-color:${bgColor};"></span> Color ${colorIdx + 1}`;
                         if (colorIdx === currentPaletteIndex) {
                             option.selected = true;
                         }
                         colorSelect.appendChild(option);
                     });

                     colorSelect.addEventListener('change', handleColorSelectChange);

                     assignmentDiv.appendChild(segmentLabel);
                     assignmentDiv.appendChild(colorSelect);
                     colorAssignmentContainer.appendChild(assignmentDiv);
                 });
             } else {
                 // Regular chart - create selectors for each dataset
             datasets.forEach((ds, datasetIndex) => {
                 const currentBgColor = ds.backgroundColor || selectedPalette.bg[datasetIndex % numColorsInPalette]; // Get current color

                 const assignmentDiv = document.createElement('div');
                 assignmentDiv.className = 'flex items-center justify-between mb-2';

                 const label = document.createElement('label');
                 label.textContent = ds.label || `Dataset ${datasetIndex + 1}`;
                 label.className = 'text-sm text-gray-700 mr-2 truncate flex-1'; // Allow label to take space
                 label.htmlFor = `color-select-${datasetIndex}`;

                 const colorSelect = document.createElement('select');
                 colorSelect.id = `color-select-${datasetIndex}`;
                 colorSelect.dataset.datasetIndex = datasetIndex; // Store index
                 colorSelect.className = 'color-assign-select'; // Apply specific class if needed

                 // Find which palette color is currently assigned (approximately)
                 // This is tricky if opacity was applied or color was custom picked before.
                 // For simplicity, default selection to the standard modulo assignment.
                 let currentPaletteIndex = datasetIndex % numColorsInPalette;

                 // Populate dropdown with colors from the selected palette
                 selectedPalette.bg.forEach((bgColor, colorIdx) => {
                     const option = document.createElement('option');
                     option.value = colorIdx; // Store the index of the color in the palette
                     option.style.backgroundColor = bgColor;
                     option.style.color = getContrastYIQ(bgColor); // Set text color for contrast
                     option.innerHTML = `<span class="color-assign-option-color" style="background-color:${bgColor};"></span> Color ${colorIdx + 1}`;
                     if (colorIdx === currentPaletteIndex) {
                         option.selected = true; // Select the default assigned color
                     }
                     colorSelect.appendChild(option);
                 });

                 colorSelect.addEventListener('change', handleColorSelectChange);

                 assignmentDiv.appendChild(label);
                 assignmentDiv.appendChild(colorSelect);
                 colorAssignmentContainer.appendChild(assignmentDiv);
             });
             }

             colorOverrideSection.classList.remove('hidden');
         }

         /**
          * Handles changes from the individual color assignment dropdowns.
          */
         function handleColorSelectChange(event) {
             if (!chartInstance) return;

             const selectedColorIndex = parseInt(event.target.value, 10);
             const datasetIndex = parseInt(event.target.dataset.datasetIndex, 10);
             const segmentIndex = event.target.dataset.segmentIndex ? parseInt(event.target.dataset.segmentIndex, 10) : null;
             const paletteIndex = parseInt(colorPaletteSelect.value, 10) || 0;
             const selectedPalette = PALETTES[paletteIndex] || PALETTES[0];

             if (isNaN(datasetIndex) || datasetIndex >= chartInstance.data.datasets.length ||
                 isNaN(selectedColorIndex) || selectedColorIndex >= selectedPalette.bg.length) {
                 return;
             }

             // Get the chosen color from the selected palette
             const newBgColor = selectedPalette.bg[selectedColorIndex];
             const newBorderColor = selectedPalette.border[selectedColorIndex];

             // Update the specific dataset
             const dataset = chartInstance.data.datasets[datasetIndex];
             
             // Special handling for pie and doughnut charts
             if (chartInstance.config.type === 'pie' || chartInstance.config.type === 'doughnut') {
                 // For pie/doughnut charts, each slice has its own color
                 if (segmentIndex !== null && !isNaN(segmentIndex)) {
                     // If we have a specific segment index, update just that segment's color
                     if (Array.isArray(dataset.backgroundColor) && segmentIndex < dataset.backgroundColor.length) {
                         dataset.backgroundColor[segmentIndex] = newBgColor;
                     }
                 } else {
                     // If changing the overall dataset color, regenerate all colors from the palette
                     const colors = [];
                     for (let i = 0; i < chartInstance.data.labels.length; i++) {
                         colors.push(selectedPalette.bg[i % selectedPalette.bg.length]);
                     }
                     dataset.backgroundColor = colors;
                 }
                 
                 // Keep transparent borders for pie/doughnut
                 dataset.borderColor = 'transparent';
                 dataset.borderWidth = 0;
                 
                 // Force legend items to have 0 border width
                 if (chartInstance.legend && chartInstance.legend.legendItems) {
                     chartInstance.legend.legendItems.forEach(item => {
                         item.borderWidth = 0;
                     });
                 }
             } else {
                 // For regular charts, just update the dataset color
                 dataset.backgroundColor = newBgColor;
                 dataset.borderColor = newBorderColor;
                 
                 // Set appropriate border width based on chart type
                 if (chartInstance.config.type === 'line') {
                     // Line charts need visible borders (lines)
                     const lineWidth = parseInt(lineWidthInput.value, 10) || DEFAULT_LINE_WIDTH;
                     dataset.borderWidth = lineWidth;
                 } else if (chartInstance.config.type === 'scatter') {
                     // Scatter charts need a border width of 1 for visibility
                     dataset.borderWidth = 1;
                 } else {
                     // All other chart types can have border width 0
                     dataset.borderWidth = 0;
                 }
             }

             chartInstance.update(); // Update the chart visually
             
             // Determine what message to show based on what was updated
             let statusMsg;
             if (chartInstance.config.type === 'pie' || chartInstance.config.type === 'doughnut') {
                 if (segmentIndex !== null) {
                     const segmentLabel = chartInstance.data.labels[segmentIndex];
                     statusMsg = `Updated color for segment: ${segmentLabel}`;
                 } else {
                     statusMsg = 'Updated colors for pie/doughnut chart';
                 }
             } else {
                 statusMsg = `Updated color for dataset: ${dataset.label || `Dataset ${datasetIndex + 1}`}`;
             }
             
             showStatus(statusMsg);
         }


        /**
         * Generates the chart based on selected type and data.
         */
        function generateChart(labels, datasets) {
            labels = labels || currentChartData.labels; 
            datasets = datasets || currentChartData.datasets; 
            
            if (!labels || !datasets || datasets.length === 0) { 
                showError("Cannot generate chart: missing data."); 
                return;
            }
            
            currentChartData = { labels, datasets }; 
            
            if (!chartCanvas) { 
                showError("Canvas element not found."); 
                return; 
            } 
            
            const ctx = chartCanvas.getContext('2d'); 
            if (!ctx) { 
                showError("Failed to get canvas context."); 
                return; 
            } 
            
            // Ensure previous chart is properly destroyed
            if (chartInstance) { 
                try {
                chartInstance.destroy(); 
                } catch (err) {
                    console.error("Error destroying previous chart:", err);
                }
                chartInstance = null; 
            } 
            
            // For additional safety, check if Chart.js still thinks the canvas is in use
            const existingChart = Chart.getChart(chartCanvas);
            if (existingChart) {
                try {
                    existingChart.destroy();
                    console.log("Destroyed lingering chart reference");
                } catch (err) {
                    console.error("Error destroying lingering chart:", err);
                }
            }
            
            chartPlaceholder.classList.add('hidden');

            const selectedTypeOption = chartTypeSelect.value;
            let chartType = 'bar'; let indexAxis = 'x';
            const baseFontSize = Chart.defaults.font.size || 12;
            
            // Get custom axis titles or use default values
            let xAxisTitleText = xAxisTitleInput.value || '';
            let yAxisTitleText = yAxisTitleInput.value || '';
            
            const transposeEnabled = toggleTransposeCheckbox.checked;
            const parseDates = false; // Always false since we removed the date functionality
            const showLegend = toggleLegendCheckbox.checked;

            let chartLabels = labels;
            let datasetsForChart = JSON.parse(JSON.stringify(datasets)); // Use clone
            let chartDataConfig;

            // Apply selected color palette and set borderWidth
            applyPalette(datasetsForChart); // Apply colors and set borderWidth

            // Modify data for time scale if dates are used and not transposed
            if (parseDates && !transposeEnabled && ['line', 'column', 'bar', 'area', 'areaStacked', 'scatter', 'columnStacked', 'columnStacked100', 'barStacked', 'barStacked100'].includes(selectedTypeOption)) { /* ... Time scale data formatting ... */ console.log("Formatting data for time scale"); if (selectedTypeOption === 'scatter') { datasetsForChart.forEach(ds => { ds.data = ds.data.map((yValue, index) => ({ x: chartLabels[index], y: yValue })).filter(p => p.x && p.y !== null); }); chartDataConfig = { datasets: datasetsForChart }; } else { chartDataConfig = { labels: chartLabels, datasets: datasetsForChart }; } }
            else { chartDataConfig = { labels: chartLabels, datasets: datasetsForChart }; }

            // Determine Axis Titles if not provided by user
            if (transposeEnabled && !xAxisTitleText) { xAxisTitleText = ''; }
            if (transposeEnabled && !yAxisTitleText) { yAxisTitleText = ''; }
            if (!transposeEnabled && !xAxisTitleText) { xAxisTitleText = ''; }

            // Configure Scales
            let scalesConfig = { 
                x: {
                    stacked: false, 
                    title: {
                        display: !!xAxisTitleText, 
                        text: xAxisTitleText, 
                        font: { size: baseFontSize + 2 },
                        color: chartTextColorPicker ? chartTextColorPicker.value : '#333333'
                    },
                    ticks: {
                        font: { size: baseFontSize },
                        color: chartTextColorPicker ? chartTextColorPicker.value : '#666666'
                    },
                    grid: {
                        color: 'rgba(0, 0, 0, 0.1)'
                    }
                },
                y: {
                    stacked: false, 
                    beginAtZero: true, 
                    title: {
                        display: !!yAxisTitleText, 
                        text: yAxisTitleText, 
                        font: { size: baseFontSize + 2 },
                        color: chartTextColorPicker ? chartTextColorPicker.value : '#333333'
                    },
                    ticks: {
                        font: { size: baseFontSize },
                        color: chartTextColorPicker ? chartTextColorPicker.value : '#666666'
                    },
                    grid: {
                        color: 'rgba(0, 0, 0, 0.1)'
                    }
                }
            };
            
            if (parseDates && !transposeEnabled && !selectedTypeOption.includes('bar')) { scalesConfig.x.type = 'time'; scalesConfig.x.time = { parser: dateFormat, tooltipFormat: 'll', unit: 'day' }; }
            else if (parseDates && !transposeEnabled && selectedTypeOption.includes('bar')) { scalesConfig.y.type = 'time'; scalesConfig.y.time = { parser: dateFormat, tooltipFormat: 'll', unit: 'day'}; scalesConfig.x.beginAtZero = true; }
            // Configure based on chart type
            let chartSpecificOptions = {}; const barPercentage = parseFloat(barPercentageInput.value); const categoryPercentage = parseFloat(categoryPercentageInput.value);
            let pluginConfig = { 
                legend: { 
                    display: showLegend, 
                    position: legendPosition ? legendPosition.value : 'top',
                    labels: { 
                        font: { 
                            size: legendTextSize ? parseInt(legendTextSize.value, 10) : baseFontSize,
                            family: Chart.defaults.font.family
                        },
                        usePointStyle: false,
                        boxWidth: legendBoxWidth ? parseInt(legendBoxWidth.value, 10) : 15,
                        boxHeight: legendBoxHeight ? parseInt(legendBoxHeight.value, 10) : 15,
                        pointStyle: 'rect',
                        color: chartTextColorPicker ? chartTextColorPicker.value : '#333333',
                        padding: legendItemSpacing ? parseInt(legendItemSpacing.value, 10) : 10
                    },
                    title: {
                        display: false
                    },
                    padding: legendPadding ? parseInt(legendPadding.value, 10) : 10
                }, 
                tooltip: { enabled: true }, 
                whiteBackground: { color: '#ffffff' }, 
                title: { 
                    display: chartTitleInput.value !== '', 
                    text: chartTitleInput.value, 
                    font: { size: baseFontSize + 4 },
                    color: chartTextColorPicker ? chartTextColorPicker.value : '#333333'
                },
                stacked100: { enable: false },
                datalabels: {
                    display: function(context) {
                        // Only show for pie and doughnut charts
                        const chartType = context.chart.config.type;
                        if (chartType !== 'pie' && chartType !== 'doughnut') {
                            return false;
                        }
                        
                        // Check if data labels toggle is enabled
                        if (!toggleDataLabelsCheckbox.checked) {
                            return false;
                        }
                        
                        // Automatically hide labels for small segments (less than 5% of total)
                        const dataset = context.chart.data.datasets[context.datasetIndex];
                        const total = dataset.data.reduce((sum, val) => sum + val, 0);
                        const value = dataset.data[context.dataIndex];
                        const percentage = (value / total) * 100;
                        
                        // Hide labels for small segments to prevent overlapping
                        // Labels on segments less than 5% will be hidden
                        return percentage >= 5;
                    },
                    color: function(context) {
                        // Get background color of this data item
                        const backgroundColor = context.dataset.backgroundColor;
                        let bgColor = Array.isArray(backgroundColor) ? 
                            backgroundColor[context.dataIndex] : 
                            backgroundColor;
                        
                        // If background is in rgba format, extract the rgb part
                        if (typeof bgColor === 'string') {
                            if (bgColor.startsWith('rgba(')) {
                                bgColor = bgColor.replace('rgba(', 'rgb(').replace(/,\s*[\d.]+\)/, ')');
                            }
                            
                            // Calculate brightness using YIQ formula
                            const rgb = bgColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                            if (rgb) {
                                const r = parseInt(rgb[1], 10);
                                const g = parseInt(rgb[2], 10);
                                const b = parseInt(rgb[3], 10);
                                const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
                                
                                // Return white for dark backgrounds, black for light backgrounds
                                return yiq >= 128 ? '#000000' : '#ffffff';
                            }
                        }
                        
                        // Default to white if we can't determine contrast
                        return '#ffffff';
                    },
                    font: {
                        weight: 'bold',
                        size: parseInt(dataLabelSizeInput.value, 10) || DEFAULT_LABEL_SIZE
                    },
                    formatter: (value, context) => {
                        // Format the value as a percentage of the total
                        const dataset = context.chart.data.datasets[context.datasetIndex];
                        const total = dataset.data.reduce((sum, val) => sum + val, 0);
                        const percentage = ((value / total) * 100).toFixed(1) + '%';
                        
                        // Return both value and percentage
                        return `${value}\n(${percentage})`;
                    },
                    textAlign: 'center',
                    anchor: 'center',
                    align: 'center',
                    offset: 0,
                    clamp: true
                }
            };

            if (selectedTypeOption === 'line') { 
                chartType = 'line'; 
                const lineWidth = parseInt(lineWidthInput.value, 10) || DEFAULT_LINE_WIDTH;
                datasetsForChart.forEach(ds => { 
                    // Use the user's choice for curved lines
                    ds.tension = toggleCurvedLinesCheckbox.checked ? parseFloat(lineTensionInput.value) : 0;
                    ds.fill = false; 
                    ds.borderWidth = lineWidth; // Use the line width from the slider
                    ds.pointRadius = 0; // No point dots for cleaner look
                }); 
            }
            else if (selectedTypeOption === 'area') { 
                chartType = 'line'; 
                datasetsForChart.forEach(ds => { 
                    // Use the user's choice for curved lines
                    ds.tension = toggleCurvedLinesCheckbox.checked ? parseFloat(lineTensionInput.value) : 0;
                    ds.fill = true; 
                    ds.borderWidth = 1; // Set a thin border for area charts
                    ds.pointRadius = 0; // No point dots for cleaner look
                    
                    // Add 50% transparency to the background color
                    if (ds.backgroundColor) {
                        if (typeof ds.backgroundColor === 'string') {
                            // Convert rgb to rgba with 0.5 alpha
                            if (ds.backgroundColor.startsWith('rgb(')) {
                                ds.backgroundColor = ds.backgroundColor.replace('rgb(', 'rgba(').replace(')', ', 0.5)');
                            } 
                            // If it's already rgba, modify the alpha value
                            else if (ds.backgroundColor.startsWith('rgba(')) {
                                ds.backgroundColor = ds.backgroundColor.replace(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*[\d.]+\)/, 'rgba($1, $2, $3, 0.5)');
                            }
                        } 
                        // If it's an array of colors, make each one transparent
                        else if (Array.isArray(ds.backgroundColor)) {
                            ds.backgroundColor = ds.backgroundColor.map(color => {
                                if (typeof color === 'string') {
                                    if (color.startsWith('rgb(')) {
                                        return color.replace('rgb(', 'rgba(').replace(')', ', 0.5)');
                                    } else if (color.startsWith('rgba(')) {
                                        return color.replace(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*[\d.]+\)/, 'rgba($1, $2, $3, 0.5)');
                                    }
                                }
                                return color;
                            });
                        }
                    }
                }); 
            }
            else if (selectedTypeOption === 'areaStacked') { 
                chartType = 'line'; 
                scalesConfig.y.stacked = true;
                
                datasetsForChart.forEach(ds => { 
                    // Use the user's choice for curved lines
                    ds.tension = toggleCurvedLinesCheckbox.checked ? parseFloat(lineTensionInput.value) : 0;
                    ds.fill = true; 
                    ds.borderWidth = 1; // Set a thin border for stacked area charts
                    ds.pointRadius = 0; // No point dots for cleaner look
                    
                    // Ensure solid colors (no transparency) for stacked area chart
                    if (ds.backgroundColor) {
                        if (typeof ds.backgroundColor === 'string') {
                            // If it's already rgba, convert it back to rgb (solid color)
                            if (ds.backgroundColor.startsWith('rgba(')) {
                                ds.backgroundColor = ds.backgroundColor.replace(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*[\d.]+\)/, 'rgb($1, $2, $3)');
                            }
                        } 
                        // If it's an array of colors, ensure each one is solid
                        else if (Array.isArray(ds.backgroundColor)) {
                            ds.backgroundColor = ds.backgroundColor.map(color => {
                                if (typeof color === 'string' && color.startsWith('rgba(')) {
                                    return color.replace(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*[\d.]+\)/, 'rgb($1, $2, $3)');
                                }
                                return color;
                            });
                        }
                    }
                }); 
            }
            else if (selectedTypeOption === 'bar') { 
                chartType = 'bar'; 
                indexAxis = 'y'; 
                scalesConfig = { 
                    x: { 
                        stacked: false, 
                        beginAtZero: true, 
                        title: { 
                            display: !!yAxisTitleText, 
                            text: yAxisTitleText, 
                            font: { size: baseFontSize + 2 },
                            color: chartTextColorPicker ? chartTextColorPicker.value : '#333333'
                        }, 
                        ticks: { 
                            font: { size: baseFontSize },
                            color: chartTextColorPicker ? chartTextColorPicker.value : '#666666'
                        },
                        grid: {
                            color: 'rgba(0, 0, 0, 0.1)'
                        }
                    }, 
                    y: { 
                        stacked: false, 
                        title: { 
                            display: !!xAxisTitleText, 
                            text: xAxisTitleText, 
                            font: { size: baseFontSize + 2 },
                            color: chartTextColorPicker ? chartTextColorPicker.value : '#333333'
                        }, 
                        ticks: { 
                            font: { size: baseFontSize },
                            color: chartTextColorPicker ? chartTextColorPicker.value : '#666666'
                        },
                        grid: {
                            color: 'rgba(0, 0, 0, 0.1)'
                        }
                    } 
                }; 
                
                if (parseDates && !transposeEnabled) { 
                    scalesConfig.y.type = 'time'; 
                    scalesConfig.y.time = { 
                        parser: dateFormat, 
                        tooltipFormat: 'll', 
                        unit: 'day'
                    }; 
                } 
                
                datasetsForChart.forEach(ds => { 
                    ds.barPercentage = barPercentage; 
                    ds.categoryPercentage = categoryPercentage; 
                }); 
            }
            else if (selectedTypeOption === 'pie') { 
                chartType = 'pie'; 
                indexAxis = undefined; 
                scalesConfig = {}; 
                
                // Add pie-specific legend configuration
                pluginConfig.legend.labels.generateLabels = function(chart) {
                    // Get the default legend items
                    const original = Chart.overrides.pie.plugins.legend.labels.generateLabels(chart);
                    
                    // Override borderWidth to always be 0 for legend items
                    original.forEach(item => {
                        item.borderWidth = 0;
                    });
                    
                    return original;
                };
                
                if (datasetsForChart.length > 0) {
                    const firstDataset = datasetsForChart[0];
                    
                    // Ensure backgroundColor is an array of colors, one for each data point
                    if (!Array.isArray(firstDataset.backgroundColor)) {
                        // If not already an array, create an array with colors from the palette
                        firstDataset.backgroundColor = [];
                        const paletteIndex = parseInt(colorPaletteSelect.value, 10) || 0;
                        const selectedPalette = PALETTES[paletteIndex] || PALETTES[0];
                        
                        if (firstDataset.data && firstDataset.data.length > 0) {
                            firstDataset.data.forEach((_, i) => {
                                const colorIndex = i % selectedPalette.bg.length;
                                firstDataset.backgroundColor.push(selectedPalette.bg[colorIndex]);
                            });
                        }
                    }
                    
                    chartDataConfig = { labels: labels, datasets: [firstDataset] }; 
                    showStatus("Displaying Pie Chart for the first data series found."); 
                } else { 
                    showError("No data series available for Pie Chart."); 
                    return; 
                } 
            }
            else if (selectedTypeOption === 'doughnut') { 
                chartType = 'doughnut'; 
                indexAxis = undefined; 
                scalesConfig = {}; 
                
                // Add doughnut-specific legend configuration
                pluginConfig.legend.labels.generateLabels = function(chart) {
                    // Get the default legend items
                    const original = Chart.overrides.pie.plugins.legend.labels.generateLabels(chart);
                    
                    // Override borderWidth to always be 0 for legend items
                    original.forEach(item => {
                        item.borderWidth = 0;
                    });
                    
                    return original;
                };
                
                if (datasetsForChart.length > 0) {
                    const firstDataset = datasetsForChart[0];
                    
                    // Ensure backgroundColor is an array of colors, one for each data point
                    if (!Array.isArray(firstDataset.backgroundColor)) {
                        // If not already an array, create an array with colors from the palette
                        firstDataset.backgroundColor = [];
                        const paletteIndex = parseInt(colorPaletteSelect.value, 10) || 0;
                        const selectedPalette = PALETTES[paletteIndex] || PALETTES[0];
                        
                        if (firstDataset.data && firstDataset.data.length > 0) {
                            firstDataset.data.forEach((_, i) => {
                                const colorIndex = i % selectedPalette.bg.length;
                                firstDataset.backgroundColor.push(selectedPalette.bg[colorIndex]);
                            });
                        }
                    }
                    
                    chartDataConfig = { labels: labels, datasets: [firstDataset] }; 
                    
                    // Get inner radius value from slider (0-90%)
                    const innerRadiusPercent = parseInt(innerRadiusInput.value, 10) || DEFAULT_INNER_RADIUS;
                    const innerRadiusRatio = innerRadiusPercent / 100;
                    
                    // Add cutout percentage option for doughnut
                    chartSpecificOptions = {
                        cutout: `${innerRadiusPercent}%`
                    };
                    
                    showStatus(`Displaying Doughnut Chart for the first data series found. Inner radius: ${innerRadiusPercent}%`); 
                } else { 
                    showError("No data series available for Doughnut Chart."); 
                    return; 
                } 
            }
            else if (selectedTypeOption === 'scatter') { chartType = 'scatter'; indexAxis = 'x'; datasetsForChart.forEach(ds => { ds.showLine = false; ds.pointRadius = 5; ds.borderWidth = 1; }); }
            else if (selectedTypeOption === 'columnStacked') { 
                chartType = 'bar'; 
                indexAxis = 'x'; 
                scalesConfig.x.stacked = true; // Setting both axes to stacked for proper stacking
                scalesConfig.y.stacked = true; 
                datasetsForChart.forEach(ds => { 
                    ds.barPercentage = barPercentage; 
                    ds.categoryPercentage = categoryPercentage; 
                }); 
            }
             else if (selectedTypeOption === 'barStacked') { 
                chartType = 'bar'; 
                indexAxis = 'y'; 
                scalesConfig = { 
                    x: { 
                        stacked: true, 
                        beginAtZero: true, 
                        title: { 
                            display: !!yAxisTitleText, 
                            text: yAxisTitleText, 
                            font: { size: baseFontSize + 2 },
                            color: chartTextColorPicker ? chartTextColorPicker.value : '#333333'
                        }, 
                        ticks: { 
                            font: { size: baseFontSize },
                            color: chartTextColorPicker ? chartTextColorPicker.value : '#666666'
                        },
                        grid: {
                            color: 'rgba(0, 0, 0, 0.1)'
                        }
                    }, 
                    y: { 
                        stacked: true, // Setting y-axis to stacked for proper stacking
                        title: { 
                            display: !!xAxisTitleText, 
                            text: xAxisTitleText, 
                            font: { size: baseFontSize + 2 },
                            color: chartTextColorPicker ? chartTextColorPicker.value : '#333333'
                        }, 
                        ticks: { 
                            font: { size: baseFontSize },
                            color: chartTextColorPicker ? chartTextColorPicker.value : '#666666'
                        },
                        grid: {
                            color: 'rgba(0, 0, 0, 0.1)'
                        }
                    } 
                }; 
                
                if (parseDates && !transposeEnabled) { 
                    scalesConfig.y.type = 'time'; 
                    scalesConfig.y.time = { 
                        parser: dateFormat, 
                        tooltipFormat: 'll', 
                        unit: 'day'
                    }; 
                } 
                
                datasetsForChart.forEach(ds => { 
                    ds.barPercentage = barPercentage; 
                    ds.categoryPercentage = categoryPercentage; 
                }); 
            }
            else if (selectedTypeOption === 'columnStacked100') { chartType = 'bar'; indexAxis = 'x'; scalesConfig.x.stacked = true; scalesConfig.y.stacked = true; pluginConfig.stacked100 = { enable: true, precision: 1 }; scalesConfig.y.ticks.callback = function(value) { return value.toFixed(0) + "%" }; datasetsForChart.forEach(ds => { ds.barPercentage = barPercentage; ds.categoryPercentage = categoryPercentage; }); }
             else if (selectedTypeOption === 'barStacked100') { 
                chartType = 'bar'; 
                indexAxis = 'y'; 
                scalesConfig.x.stacked = true; 
                scalesConfig.y.stacked = true; 
                pluginConfig.stacked100 = { enable: true, precision: 1 }; 
                scalesConfig = { 
                    x: { 
                        stacked: true, 
                        beginAtZero: true, 
                        title: { 
                            display: !!yAxisTitleText, 
                            text: yAxisTitleText, 
                            font: { size: baseFontSize + 2 },
                            color: chartTextColorPicker ? chartTextColorPicker.value : '#333333'
                        }, 
                        ticks: { 
                            font: { size: baseFontSize }, 
                            callback: function(value) { return value.toFixed(0) + "%" },
                            color: chartTextColorPicker ? chartTextColorPicker.value : '#666666'
                        },
                        grid: {
                            color: 'rgba(0, 0, 0, 0.1)'
                        }
                    }, 
                    y: { 
                        stacked: true, 
                        title: { 
                            display: !!xAxisTitleText, 
                            text: xAxisTitleText, 
                            font: { size: baseFontSize + 2 },
                            color: chartTextColorPicker ? chartTextColorPicker.value : '#333333'
                        }, 
                        ticks: { 
                            font: { size: baseFontSize },
                            color: chartTextColorPicker ? chartTextColorPicker.value : '#666666'
                        },
                        grid: {
                            color: 'rgba(0, 0, 0, 0.1)'
                        }
                    } 
                }; 
                
                if (parseDates && !transposeEnabled) { 
                    scalesConfig.y.type = 'time'; 
                    scalesConfig.y.time = { 
                        parser: dateFormat, 
                        tooltipFormat: 'll', 
                        unit: 'day'
                    }; 
                } 
                
                datasetsForChart.forEach(ds => { 
                    ds.barPercentage = barPercentage; 
                    ds.categoryPercentage = categoryPercentage; 
                }); 
            }
            else { /* column */ chartType = 'bar'; indexAxis = 'x'; datasetsForChart.forEach(ds => { ds.barPercentage = barPercentage; ds.categoryPercentage = categoryPercentage; }); }

            // Final Chart Options
            currentChartOptions = { 
                responsive: true, 
                maintainAspectRatio: false, // We'll handle resizing ourselves
                indexAxis: indexAxis, 
                scales: scalesConfig, 
                plugins: pluginConfig, 
                animation: false, 
                ...chartSpecificOptions 
            };
            
            // For pie and doughnut charts, we don't use scales or indexAxis
            if (chartType === 'pie' || chartType === 'doughnut') { 
                delete currentChartOptions.scales; 
                delete currentChartOptions.indexAxis; 
            }

            // Update chart display dimensions before creating the chart
            updateChartDisplay();

            // Create Chart
            try {
                // Handle any lingering canvas issues before creating new chart
                try {
                    // Reset the canvas by replacing it with a new one
                    if (Chart.getChart(chartCanvas)) {
                        const newCanvas = document.createElement('canvas');
                        newCanvas.id = 'myChart';
                        
                        // Copy any necessary attributes and set to current dimensions
                        newCanvas.style.width = `${chartWidth}px`;
                        newCanvas.style.height = `${chartHeight}px`;
                        
                        // Handle device pixel ratio for better resolution
                        const dpr = window.devicePixelRatio || 1;
                        newCanvas.width = chartWidth * dpr;
                        newCanvas.height = chartHeight * dpr;
                        
                        // Replace the old canvas
                        chartCanvas.parentNode.replaceChild(newCanvas, chartCanvas);
                        chartCanvas = newCanvas;
                        ctx = newCanvas.getContext('2d');
                        
                        // Scale context for device pixel ratio
                        if (dpr > 1) {
                            ctx.scale(dpr, dpr);
                        }
                    } else {
                        // If there's no existing chart, just set the dimensions on the current canvas
                        chartCanvas.style.width = `${chartWidth}px`;
                        chartCanvas.style.height = `${chartHeight}px`;
                        
                        // Handle device pixel ratio
                        const dpr = window.devicePixelRatio || 1;
                        chartCanvas.width = chartWidth * dpr;
                        chartCanvas.height = chartHeight * dpr;
                        
                        // Scale context for device pixel ratio
                        if (dpr > 1) {
                            ctx.scale(dpr, dpr);
                        }
                    }
                } catch (resetErr) {
                    console.error("Error trying to reset canvas:", resetErr);
                }
                
                // Create the new chart
                chartInstance = new Chart(ctx, { 
                    type: chartType, 
                    data: chartDataConfig, 
                    options: currentChartOptions, 
                    plugins: [whiteBackgroundPlugin, legendMarginPlugin] 
                });
                
                downloadBtn.disabled = false;
                
                // Populate/Update color selectors AFTER chart instance exists
                populateColorSelectors(chartInstance.data.datasets);
                
                let statusMsg = `Chart generated/updated successfully (Type: ${chartTypeSelect.options[chartTypeSelect.selectedIndex].text}).`; 
                if (chartType === 'pie' && datasets.length > 1) { 
                    statusMsg += ` Showing data for '${datasets[0].label}'.`; 
                } 
                showStatus(statusMsg);
            } catch (error) { 
                console.error("Chart.js error:", error); 
                
                // Special handling for "Canvas is already in use" error
                if (error.message && error.message.includes("Canvas is already in use")) {
                    showError("Canvas reuse error. Please refresh the page and try again.");
                    console.log("Attempting recovery...");
                    
                    // Attempt recovery by resetting the DOM
                    setTimeout(() => {
                        try {
                            // Create a completely new canvas
                            const chartContainer = document.getElementById('chartWrapper');
                            if (chartContainer) {
                                // Remove existing canvas
                                while (chartContainer.firstChild) {
                                    chartContainer.removeChild(chartContainer.firstChild);
                                }
                                
                                // Create new canvas
                                const newCanvas = document.createElement('canvas');
                                newCanvas.id = 'myChart';
                                chartContainer.appendChild(newCanvas);
                                
                                // Update reference
                                chartCanvas = newCanvas;
                                showStatus("Chart display reset. Try generating a chart again.");
                            }
                        } catch (recoveryErr) {
                            console.error("Recovery failed:", recoveryErr);
                        }
                    }, 500);
                } else {
                showError(`Failed to create chart: ${error.message}`); 
                }
                
                chartPlaceholder.classList.remove('hidden'); 
                downloadBtn.disabled = true; 
                chartInstance = null; 
            }
        }

        /**
         * Toggle visibility of bar settings for bar chart types
         */
        function toggleBarSettingsVisibility() {
            const chartType = chartTypeSelect.value;
            if (chartType === 'bar' || chartType === 'horizontalBar') {
                barSettingsDiv.style.display = 'block';
            } else {
                barSettingsDiv.style.display = 'none';
            }

            if (chartType === 'doughnut' || chartType === 'pie') {
                doughnutSettingsDiv.style.display = 'block';
            } else {
                doughnutSettingsDiv.style.display = 'none';
            }
        }

        // This function replaces toggleBarSettingsVisibility
        function toggleChartSettingsVisibility() {
            const chartType = chartTypeSelect.value;
            
            // Hide all settings first
            barSettingsDiv.style.display = 'none';
            doughnutSettingsDiv.style.display = 'none';
            lineSettingsDiv.style.display = 'none';
            
            // Show relevant settings based on chart type
            if (chartType === 'bar' || chartType === 'horizontalBar' || 
                chartType === 'column' || chartType === 'columnStacked' || 
                chartType === 'columnStacked100' || chartType === 'barStacked' || 
                chartType === 'barStacked100') {
                barSettingsDiv.style.display = 'block';
            } 
            else if (chartType === 'doughnut' || chartType === 'pie') {
                doughnutSettingsDiv.style.display = 'block';
            }
            else if (chartType === 'line' || chartType === 'area' || chartType === 'areaStacked') {
                lineSettingsDiv.style.display = 'block';
                updateCurveSettingsVisibility();
            }
        }
        
        // Function to update visibility of curve settings based on curved lines checkbox
        function updateCurveSettingsVisibility() {
            if (toggleCurvedLinesCheckbox.checked) {
                curveSettingsContainer.style.display = 'block';
            } else {
                curveSettingsContainer.style.display = 'none';
            }
        }

        /**
         * Resets chart dimensions to default values.
         */
        function resetChartDimensions() {
            chartWidthInput.value = DEFAULT_CHART_WIDTH;
            chartHeightInput.value = DEFAULT_CHART_HEIGHT;
            maintainAspectRatioCheckbox.checked = true;
            previewModeToggle.checked = false; // Keep preview mode disabled
            
            chartWidth = DEFAULT_CHART_WIDTH;
            chartHeight = DEFAULT_CHART_HEIGHT;
            aspectRatio = chartWidth / chartHeight;
            previewModeEnabled = false; // Keep preview mode disabled
            
            // Update chart display
            updateChartDisplay();
            
            // Update canvas dimensions
            if (chartCanvas) {
                chartCanvas.style.width = `${chartWidth}px`;
                chartCanvas.style.height = `${chartHeight}px`;
            }
            
            // Regenerate chart if it exists
            if (chartInstance) {
                try {
                    chartInstance.destroy();
                    generateChart(currentChartData.labels, currentChartData.datasets);
                } catch (err) {
                    console.error("Error recreating chart after reset:", err);
                    // Try to handle lingering chart instances
                    const existingChart = Chart.getChart(chartCanvas);
                    if (existingChart) {
                        try {
                            existingChart.destroy();
                            generateChart(currentChartData.labels, currentChartData.datasets);
                        } catch (err2) {
                            console.error("Error clearing lingering chart after reset:", err2);
                        }
                    }
                }
            }
            
            console.log("Chart dimensions reset to default");
            showStatus("Chart dimensions reset to default");
        }

        /**
         * Updates the chart display based on dimensions and preview mode.
         */
        function updateChartDisplay() {
            if (!chartWrapper) return;
            
            // Get available space in container (accounting for padding)
            const containerWidth = chartContainer.clientWidth - 40; // 20px padding on each side
            const containerHeight = chartContainer.clientHeight - 40;
            
            console.log(`updateChartDisplay - chartWidth: ${chartWidth}, chartHeight: ${chartHeight}`);
            console.log(`Container dimensions: ${containerWidth}x${containerHeight}`);
            
            // Set the actual dimensions text
            if (actualDimensions) {
                actualDimensions.textContent = `${chartWidth}px Ã— ${chartHeight}px`;
            }
            
            // Always use exact dimensions (scale to fit disabled)
            chartWrapper.style.width = `${chartWidth}px`;
            chartWrapper.style.height = `${chartHeight}px`;
            chartWrapper.style.minHeight = `${chartHeight}px`; // Ensure min-height is set
            chartWrapper.style.marginTop = '0';
            chartWrapper.style.marginLeft = '0'; // Reset any left margin
            
            console.log(`Set chartWrapper dimensions to: ${chartWidth}x${chartHeight}`);
            
            // Always ensure scroll is enabled
            chartContainer.style.overflowX = 'auto';
            chartContainer.style.overflowY = 'auto';
            
            // Ensure the chart container has enough height to show scrollbar
            // Add a minimum height to the container if needed to show scrollbars
            if (chartHeight > containerHeight) {
                // Set explicit min-height to ensure scrollbar has enough space
                const minScrollThumb = 30; // Minimum size of scroll thumb in pixels
                const visibleRatio = containerHeight / chartHeight;
                const scrollThumbHeight = Math.max(containerHeight * visibleRatio, minScrollThumb);
                const scrollbarSpace = scrollThumbHeight * (chartHeight / containerHeight);
                
                console.log(`Chart exceeds container - height: ${chartHeight}px, container: ${containerHeight}px, ratio: ${visibleRatio.toFixed(2)}`);
                console.log(`Scrollable area: ${chartHeight - containerHeight}px`);
            } else {
                console.log(`Chart fits in container - height: ${chartHeight}px, container: ${containerHeight}px`);
            }
            
            // Hide preview mode indicator
            if (previewModeIndicator) {
                previewModeIndicator.classList.add('hidden');
            }
        }

        // Timer reference for preview indicator fade
        let previewIndicatorTimer = null;

        /**
         * Sets up auto-fade for the preview mode indicator after 3 seconds
         */
        function setupPreviewIndicatorFade() {
            // Clear any existing timer
            if (previewIndicatorTimer) {
                clearTimeout(previewIndicatorTimer);
            }
            
            // Set new timer to fade out after 3 seconds
            previewIndicatorTimer = setTimeout(() => {
                if (previewModeIndicator) {
                    previewModeIndicator.classList.add('fade-out');
                }
            }, 3000);
        }

        /**
         * Shows the preview indicator temporarily (used when triggered by events)
         */
        function flashPreviewIndicator() {
            if (previewModeEnabled && previewModeIndicator) {
                // Make sure it's visible and not faded
                previewModeIndicator.classList.remove('hidden');
                previewModeIndicator.classList.remove('fade-out');
                
                // Set up fade timer
                setupPreviewIndicatorFade();
            }
        }

        /**
         * Handles window resize event for responsive chart display.
         */
        function handleWindowResize() {
            if (chartInstance) {
                updateChartDisplay();
            }
        }

        /**
         * Reprocesses stored data based on current toggle states and regenerates chart and table.
         */
        function reprocessAndRegenerate() {
            if (!parsedRawData || parsedRawData.length === 0) { 
                showError("No data loaded to reprocess."); 
                return; 
            }
            showStatus("Re-analyzing data and updating display...");

            // Update state based on UI controls
            isTransposed = toggleTransposeCheckbox.checked;
            useFirstRowAsHeaders = toggleUseFirstRowAsHeadersCheckbox.checked;
            // Removed date-related toggles
            treatFirstColAsDates = false; 

            console.log(`Reprocessing with transpose=${isTransposed}, useFirstRowAsHeaders=${useFirstRowAsHeaders}`);

            // --- No longer update the table display when toggling transpose ---
            // Table will remain in the original CSV format for better user experience

            // --- Analyze Data for Chart ---
            console.log("Reprocessing - Analyzing for chart...");
            const chartData = analyzeData(parsedRawData, originalHeaders, isTransposed, false, 'YYYY-MM-DD');

            // --- Generate Chart ---
            if (chartData) {
                console.log("Reprocessing - Generating chart...");
                generateChart(chartData.labels, chartData.datasets);
            } else {
                console.log("Reprocessing - Analysis failed, clearing chart.");
                if (chartInstance) { chartInstance.destroy(); chartInstance = null; }
                chartPlaceholder.classList.remove('hidden');
                downloadBtn.disabled = true;
            }
        }


        // --- Event Listeners ---
        csvFileInput.addEventListener('change', handleFileSelect);
        dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('drag-active'); });
        dropZone.addEventListener('dragleave', () => { dropZone.classList.remove('drag-active'); });
        dropZone.addEventListener('drop', handleFileDrop);

        function handleFileSelect(event) { const file = event.target.files[0]; if (file) { processFile(file); } }
        function handleFileDrop(event) { event.preventDefault(); dropZone.classList.remove('drag-active'); if (event.dataTransfer.files.length) { csvFileInput.files = event.dataTransfer.files; const changeEvent = new Event('change'); csvFileInput.dispatchEvent(changeEvent); } }

        function processFile(file) {
            resetUI(); 
            if (!file) { return; } 
            if (!file.name.toLowerCase().endsWith('.csv')) { 
                showError("Invalid file type."); 
                csvFileInput.value = ''; 
                return; 
            }
            
            // Set initial state from UI controls
            isTransposed = toggleTransposeCheckbox.checked;
            useFirstRowAsHeaders = toggleUseFirstRowAsHeadersCheckbox.checked;
            // Removed date-related toggles
            treatFirstColAsDates = false;
            
            // Display the CSV filename
            if (csvFilenameDisplay) {
                csvFilenameDisplay.textContent = file.name;
            }

            console.log("Analyzing CSV file..."); 
            showStatus("Parsing CSV file...");
            
            // Simplify CSV parsing - always parse with header=false and use row indices
                Papa.parse(file, {
                header: false,
                    skipEmptyLines: true,
                    dynamicTyping: false,
                    complete: function(results) {
                        if (results.errors.length > 0) { 
                            const errorDetails = results.errors.map(err => `Row ${err.row}: ${err.message}`).join('; '); 
                            console.error("Parsing errors:", results.errors); 
                            showError(`Error parsing CSV: ${errorDetails.substring(0, 200)}${errorDetails.length > 200 ? '...' : ''}.`); 
                            csvFileInput.value = ''; 
                            return; 
                        }
                        
                        if (!results.data || results.data.length === 0) { 
                            showError("CSV file contains no data rows."); 
                            csvFileInput.value = ''; 
                            return; 
                        }
                        
                    // Generate column headers based on array indices
                    // First row is position 0, we'll treat all csv files as headerless
                    const columnCount = results.data[0].length;
                            
                            if (columnCount < 2) {
                                showError("CSV needs at least 2 columns.");
                                return;
                            }
                            
                    // Create numeric headers (0, 1, 2, ...)
                    originalHeaders = Array.from({ length: columnCount }, (_, i) => i.toString());
                    
                    // Convert the array data to objects with numeric indices as keys
                            parsedRawData = results.data.map(row => {
                                const obj = {};
                                row.forEach((val, idx) => {
                            obj[idx.toString()] = val;
                                });
                                return obj;
                            });
                        
                    // Display data table in original CSV format, regardless of transpose setting
                    // This ensures the table always shows exactly what was in the CSV file
                        let displayData = parsedRawData;
                        let displayHeaders = originalHeaders;
                        const displayDataUsesHeaders = true;
                        
                        displayDataTable(displayHeaders, displayData, displayDataUsesHeaders, null);

                        // Show configuration section and prepare chart
                        configSection.classList.remove('hidden'); 
                        chartTypeSelect.disabled = false;
                        colorPaletteSelect.disabled = false;
                        toggleChartSettingsVisibility();
                        
                        // Update header toggle text based on transpose state
                        updateHeaderToggleText();
                        
                        // Analyze data and generate chart
                        const chartData = analyzeData(parsedRawData, originalHeaders, isTransposed, treatFirstColAsDates, dateFormat);
                        if (chartData) { 
                            generateChart(chartData.labels, chartData.datasets); 
                        } else { 
                            downloadBtn.disabled = true; 
                        }
                    },
                    error: function(error) { 
                        console.error("Papa Parse error:", error); 
                        showError(`Failed to read file: ${error.message}`); 
                        csvFileInput.value = ''; 
                        resetUI(); 
                    }
                });
        }

        // Update chart but NOT table when transpose toggle changes
        // Table always shows the original CSV format for better usability
        toggleTransposeCheckbox.addEventListener('change', function() { 
            updateHeaderToggleText();
            reprocessAndRegenerate(); 
        });
        
        // Update toggle label text based on transpose state
        function updateHeaderToggleText() {
            if (useHeadersToggleText) {
                useHeadersToggleText.textContent = isTransposed ? 
                    "Use column 1 as headers" : 
                    "Use row 1 as headers";
            }
        }
        
        // Handle header toggle changes
        toggleUseFirstRowAsHeadersCheckbox.addEventListener('change', function() {
            useFirstRowAsHeaders = this.checked;
            reprocessAndRegenerate();
        });
        
        // Update title instantly
        chartTitleInput.addEventListener('input', () => { if (chartInstance && chartInstance.options.plugins.title) { chartInstance.options.plugins.title.text = chartTitleInput.value; chartInstance.options.plugins.title.display = chartTitleInput.value !== ''; chartInstance.update(); } });
        
        // Update X-axis title instantly
        xAxisTitleInput.addEventListener('input', () => {
            if (chartInstance && chartInstance.options.scales && chartInstance.options.scales.x) {
                chartInstance.options.scales.x.title.text = xAxisTitleInput.value;
                chartInstance.options.scales.x.title.display = xAxisTitleInput.value !== '';
                chartInstance.update();
            }
        });
        
        // Update Y-axis title instantly
        yAxisTitleInput.addEventListener('input', () => {
            if (chartInstance && chartInstance.options.scales && chartInstance.options.scales.y) {
                chartInstance.options.scales.y.title.text = yAxisTitleInput.value;
                chartInstance.options.scales.y.title.display = yAxisTitleInput.value !== '';
                chartInstance.update();
            }
        });
        
        // Toggle legend display
        toggleLegendCheckbox.addEventListener('change', function() {
            if (chartInstance && chartInstance.options.plugins.legend) {
                chartInstance.options.plugins.legend.display = this.checked;
                chartInstance.update();
                
                // Show/hide legend settings based on toggle state
                legendSettings.style.display = this.checked ? 'block' : 'none';
            }
        });
        
        // Legend position change
        if (legendPosition) {
            legendPosition.addEventListener('change', function() {
                if (chartInstance) {
                    generateChart(currentChartData.labels, currentChartData.datasets);
                }
            });
        }
        
        // Legend box width change
        if (legendBoxWidth && legendBoxWidthValue) {
            legendBoxWidth.addEventListener('input', function() {
                legendBoxWidthValue.textContent = this.value;
                if (chartInstance) {
                    generateChart(currentChartData.labels, currentChartData.datasets);
                }
            });
        }
        
        // Legend box height change
        if (legendBoxHeight && legendBoxHeightValue) {
            legendBoxHeight.addEventListener('input', function() {
                legendBoxHeightValue.textContent = this.value;
                if (chartInstance) {
                    generateChart(currentChartData.labels, currentChartData.datasets);
                }
            });
        }
        
        // Legend item spacing change
        if (legendItemSpacing && legendItemSpacingValue) {
            legendItemSpacing.addEventListener('input', function() {
                legendItemSpacingValue.textContent = this.value;
                if (chartInstance) {
                    generateChart(currentChartData.labels, currentChartData.datasets);
                }
            });
        }
        
        // Legend overall padding change
        if (legendPadding && legendPaddingValue) {
            legendPadding.addEventListener('input', function() {
                legendPaddingValue.textContent = this.value;
                if (chartInstance) {
                    generateChart(currentChartData.labels, currentChartData.datasets);
                }
            });
        }
        
        // Legend Text Size Listener
        if (legendTextSize && legendTextSizeValue) {
            legendTextSize.addEventListener('input', function() {
                legendTextSizeValue.textContent = this.value;
                if (chartInstance) {
                    generateChart(currentChartData.labels, currentChartData.datasets);
                }
            });
        }
        
        // Legend Margin Listener
        if (legendMargin && legendMarginValue) {
            legendMargin.addEventListener('input', function() {
                legendMarginValue.textContent = this.value;
                if (chartInstance) {
                    generateChart(currentChartData.labels, currentChartData.datasets);
                }
            });
        }
        
        // Doughnut Inner Radius Listener
        innerRadiusInput.addEventListener('input', function() {
            innerRadiusValueSpan.textContent = this.value;
            if (chartInstance && chartInstance.config.type === 'doughnut') {
                // Apply the inner radius percentage
                const innerRadiusPercent = parseInt(this.value, 10);
                chartInstance.options.cutout = `${innerRadiusPercent}%`;
                chartInstance.update();
            }
        });
        
        // Data label toggle event handler
        toggleDataLabelsCheckbox.addEventListener('change', function() {
            if (chartInstance && (chartInstance.config.type === 'pie' || chartInstance.config.type === 'doughnut')) {
                // No need to modify display property directly - the function checks the toggle state
                chartInstance.update();
            }
        });
        
        // Data label size slider event handler
        dataLabelSizeInput.addEventListener('input', function() {
            dataLabelSizeValueSpan.textContent = this.value;
            if (chartInstance && (chartInstance.config.type === 'pie' || chartInstance.config.type === 'doughnut')) {
                const fontSize = parseInt(this.value, 10);
                if (chartInstance.options.plugins && chartInstance.options.plugins.datalabels) {
                    chartInstance.options.plugins.datalabels.font = { 
                        size: fontSize 
                    };
                    chartInstance.update();
                }
            }
        });
        
        // Event listeners for chart dimension inputs
        chartWidthInput.addEventListener('input', updateDimensionsInstantly);
        chartHeightInput.addEventListener('input', updateDimensionsInstantly);
        maintainAspectRatioCheckbox.addEventListener('change', updateDimensionsInstantly);
        previewModeToggle.addEventListener('change', function() {
            previewModeEnabled = this.checked;
            
            // Update max height attribute based on preview mode
            chartHeightInput.max = previewModeEnabled ? 3000 : 10000;
            
            updateChartDisplay();
            flashPreviewIndicator();
        });
        
        // Event listeners for color pickers
        if (chartBackgroundToggle) {
            chartBackgroundToggle.addEventListener('change', function() {
                if (chartInstance) {
                    // Update text colors based on background
                    if (this.checked) {
                        // Dark background - set text to white
                        updateChartTextColors('#ffffff');
                        // Set text color picker to white
                        if (chartTextColorPicker) chartTextColorPicker.value = '#ffffff';
                    } else {
                        // Light background - set text to dark gray
                        updateChartTextColors('#333333');
                        // Set text color picker to dark gray
                        if (chartTextColorPicker) chartTextColorPicker.value = '#333333';
                    }
                    chartInstance.update(); // This will trigger the whiteBackgroundPlugin
                }
            });
        }
        
        if (chartTextColorPicker) {
            chartTextColorPicker.addEventListener('change', function() {
                if (chartInstance) {
                    // Update all text colors in the chart
                    updateChartTextColors(this.value);
                }
            });
        }
        
        // Reset button event listeners
        if (resetTextColorBtn) {
            resetTextColorBtn.addEventListener('click', function() {
                if (chartTextColorPicker) {
                    // Set text color based on background mode
                    const textColor = chartBackgroundToggle && chartBackgroundToggle.checked ? '#ffffff' : '#333333';
                    chartTextColorPicker.value = textColor;
                    if (chartInstance) {
                        updateChartTextColors(textColor);
                    }
                }
            });
        }

        // Function to update all text colors in the chart
        function updateChartTextColors(color) {
            if (!chartInstance) return;
            
            // Update title color
            if (chartInstance.options.plugins.title) {
                chartInstance.options.plugins.title.color = color;
            }
            
            // Update legend labels color
            if (chartInstance.options.plugins.legend && chartInstance.options.plugins.legend.labels) {
                chartInstance.options.plugins.legend.labels.color = color;
            }
            
            // Update X axis colors if it exists
            if (chartInstance.options.scales && chartInstance.options.scales.x) {
                chartInstance.options.scales.x.ticks.color = color;
                chartInstance.options.scales.x.title.color = color;
            }
            
            // Update Y axis colors if it exists
            if (chartInstance.options.scales && chartInstance.options.scales.y) {
                chartInstance.options.scales.y.ticks.color = color;
                chartInstance.options.scales.y.title.color = color;
            }
            
            // Update the chart
            chartInstance.update();
        }

        // Function to update dimensions instantly
        function updateDimensionsInstantly() {
            const newWidth = parseInt(chartWidthInput.value, 10);
            const newHeight = parseInt(chartHeightInput.value, 10);
            
            console.log(`Attempting to set dimensions: ${newWidth}x${newHeight}`);
            
            // Different validation rules based on preview mode
            const minHeight = 200;
            const maxHeight = previewModeEnabled ? 3000 : 10000; // Allow larger heights when not in preview mode
            
            if (!isNaN(newWidth) && !isNaN(newHeight) && newWidth >= 300 && newWidth <= 5000 && 
                newHeight >= minHeight && newHeight <= maxHeight) {
                
                console.log(`Dimensions valid, updating to: ${newWidth}x${newHeight}`);
                
                // If maintaining aspect ratio, adjust the other dimension
                if (maintainAspectRatioCheckbox.checked) {
                    if (this === chartWidthInput) {
                        const adjustedHeight = Math.round(newWidth / aspectRatio);
                        console.log(`Adjusting height to maintain aspect ratio: ${adjustedHeight}`);
                        chartHeightInput.value = adjustedHeight;
                    } else if (this === chartHeightInput) {
                        const adjustedWidth = Math.round(newHeight * aspectRatio);
                        console.log(`Adjusting width to maintain aspect ratio: ${adjustedWidth}`);
                        chartWidthInput.value = adjustedWidth;
                    }
                }
                
                // Update internal values - read from inputs to ensure we get the final values
                chartWidth = parseInt(chartWidthInput.value, 10);
                chartHeight = parseInt(chartHeightInput.value, 10);
                aspectRatio = chartWidth / chartHeight;
                maintainAspectRatio = maintainAspectRatioCheckbox.checked;
                
                console.log(`Final dimensions set to: ${chartWidth}x${chartHeight}`);
                
                // Update display
                updateChartDisplay();
                
                // Properly resize and redraw the chart
                if (chartInstance) {
                    try {
                        // Update the canvas size - ensure this happens after updateChartDisplay
                        chartCanvas.style.width = `${chartWidth}px`;
                        chartCanvas.style.height = `${chartHeight}px`;
                        
                        // Set canvas element dimensions properly
                        const dpr = window.devicePixelRatio || 1;
                        chartCanvas.width = chartWidth * dpr;
                        chartCanvas.height = chartHeight * dpr;
                        
                        // Force a resize and redraw
                        chartInstance.resize();
                        chartInstance.update();
                        
                        console.log(`Chart resized to ${chartWidth}x${chartHeight}`);
                    } catch (err) {
                        console.error("Error resizing chart:", err);
                        
                        // If resize fails, recreate the chart to ensure correct size
                        try {
                            chartInstance.destroy();
                            generateChart(currentChartData.labels, currentChartData.datasets);
                            console.log("Chart recreated after resize failure");
                        } catch (recreateErr) {
                            console.error("Error recreating chart:", recreateErr);
                        }
                    }
                }
            } else {
                console.warn(`Invalid dimensions: ${newWidth}x${newHeight}`);
            }
        }

        downloadBtn.addEventListener('click', () => {
            if (!chartInstance || !chartCanvas || downloadBtn.disabled) {
                showError("Cannot download.");
                return;
            }
            
            hideMessages();
            showStatus(`Preparing ${chartWidth}px Ã— ${chartHeight}px transparent chart for download...`);
            
            try {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = chartWidth;
                tempCanvas.height = chartHeight;
                
                const tempCtx = tempCanvas.getContext('2d');
                if (!tempCtx) {
                    throw new Error("Failed to get temporary context.");
                }
                
                // Create a deep clone of the datasets to ensure we're not altering the original
                const exportDatasets = JSON.parse(JSON.stringify(chartInstance.data.datasets));
                
                // Make sure opacity settings are preserved exactly as in the preview
                exportDatasets.forEach((ds, i) => {
                    const originalDs = chartInstance.data.datasets[i];
                    // Copy exact background and border colors to ensure opacity is maintained
                    ds.backgroundColor = originalDs.backgroundColor;
                    ds.borderColor = originalDs.borderColor;
                    ds.borderWidth = originalDs.borderWidth;
                    
                    
                    // For pie charts, ensure backgroundColor is an array if needed
                    if (chartInstance.config.type === 'pie' && Array.isArray(originalDs.backgroundColor)) {
                        ds.backgroundColor = [...originalDs.backgroundColor];
                    }
                });
                
                // Create a new chart at the exact dimensions for download
                const downloadConfig = {
                    type: chartInstance.config.type,
                    data: { 
                        labels: currentChartData.labels, 
                        datasets: exportDatasets
                    },
                    options: {
                        responsive: false,
                        maintainAspectRatio: false,
                        // Copy most options from the current chart
                        indexAxis: chartInstance.config.options.indexAxis,
                        scales: chartInstance.config.options.scales,
                        plugins: {
                            title: chartInstance.config.options.plugins.title,
                            legend: chartInstance.config.options.plugins.legend,
                            tooltip: chartInstance.config.options.plugins.tooltip,
                            // Disable white background for transparency
                            whiteBackground: { enable: false }
                        },
                        animation: false
                    }
                };
                
                // Don't include the whiteBackgroundPlugin for transparent download
                const tempChart = new Chart(tempCtx, downloadConfig);
                
                setTimeout(() => {
                    try {
                        const imageURL = tempCanvas.toDataURL('image/png');
                        const link = document.createElement('a');
                        link.href = imageURL;
                        link.download = `chart_${chartWidth}x${chartHeight}_transparent.png`;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        
                        showStatus(`Transparent chart downloaded (${chartWidth}Ã—${chartHeight}px).`);
                    } catch (renderError) {
                        console.error("Error generating transparent PNG:", renderError);
                        showError(`Failed to generate transparent PNG: ${renderError.message}.`);
                    } finally {
                        if (tempChart) {
                            tempChart.destroy();
                        }
                    }
                }, 150);
            } catch (error) {
                console.error("Error during PNG download setup:", error);
                showError(`Failed to generate PNG image: ${error.message}.`);
                statusMessageArea.classList.add('hidden');
            }
        });

        downloadSampleBtn.addEventListener('click', () => { /* ... (same as before) ... */ const sampleData = `Date,Product A,Product B,Product C\n2023-01-01,120,150,80\n2023-01-02,135,145,85\n2023-01-03,125,160,90\n2023-01-04,140,155,95\n2023-01-05,130,165,100`; const blob = new Blob([sampleData], { type: 'text/csv' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'chart_sample_data.csv'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); });

        // Initialize UI state
        resetUI();
        
        // Update the toggle text on initial load
        updateHeaderToggleText();

        // Add event listeners for the preview indicator
        if (chartContainer) {
            // Show the indicator when hovering over the chart container
            chartContainer.addEventListener('mouseenter', function() {
                flashPreviewIndicator();
            });
            
            // Show the indicator when scrolling in the chart container
            chartContainer.addEventListener('wheel', function() {
                flashPreviewIndicator();
            });
        }

        // Modify dimension event listeners to show the indicator
        function updateDimensionsWithFlash() {
            updateDimensionsInstantly.call(this);
            flashPreviewIndicator();
        }
        
        // Replace existing event listeners with the new function
        chartWidthInput.removeEventListener('input', updateDimensionsInstantly);
        chartHeightInput.removeEventListener('input', updateDimensionsInstantly);
        maintainAspectRatioCheckbox.removeEventListener('change', updateDimensionsInstantly);
        
        // Use 'change' instead of 'input' for dimension inputs to avoid constant updates
        // 'change' will trigger when the input loses focus or Enter is pressed
        chartWidthInput.addEventListener('change', updateDimensionsWithFlash);
        chartHeightInput.addEventListener('change', updateDimensionsWithFlash);
        maintainAspectRatioCheckbox.addEventListener('change', updateDimensionsWithFlash);
        
        // Still update preview while typing, but don't resize the chart
        chartWidthInput.addEventListener('input', function() {
            if (actualDimensions) {
                const newWidth = parseInt(chartWidthInput.value, 10);
                const newHeight = parseInt(chartHeightInput.value, 10);
                if (!isNaN(newWidth) && !isNaN(newHeight)) {
                    actualDimensions.textContent = `${newWidth}px Ã— ${newHeight}px`;
                }
            }
        });
        
        chartHeightInput.addEventListener('input', function() {
            if (actualDimensions) {
                const newWidth = parseInt(chartWidthInput.value, 10);
                const newHeight = parseInt(chartHeightInput.value, 10);
                if (!isNaN(newWidth) && !isNaN(newHeight)) {
                    actualDimensions.textContent = `${newWidth}px Ã— ${newHeight}px`;
                }
            }
        });
        
        // Add event listener for the apply dimensions button
        if (document.getElementById('applyDimensionsBtn')) {
            document.getElementById('applyDimensionsBtn').addEventListener('click', applyChartDimensions);
        }
        
        // Preview mode toggle is now disabled
        // previewModeToggle.addEventListener('change', function() {
        //     previewModeEnabled = this.checked;
        //     updateChartDisplay();
        //     flashPreviewIndicator();
        // });

        // --- Column Resize Functionality ---
        (function() {
            const leftPanel = document.querySelector('.left-panel');
            const rightPanel = document.querySelector('.right-panel');
            const resizeHandle = document.getElementById('resizeHandle');
            let isResizing = false;
            let lastDownX = 0;
            let animationFrameId = null;
            
            // Recalculate chart container size when resizing
            function updateChartDisplay() {
                if (chartInstance && previewModeEnabled) {
                    handleWindowResize();
                }
            }
            
            function initResize(e) {
                isResizing = true;
                lastDownX = e.clientX;
                resizeHandle.classList.add('active');
                document.body.style.cursor = 'col-resize';
                
                // Add listeners
                document.addEventListener('mousemove', handleMouseMove, false);
                document.addEventListener('mouseup', stopResize, false);
                document.addEventListener('mouseleave', stopResize, false);
                
                // Prevent selection during resize
                document.body.style.userSelect = 'none';
                e.preventDefault();
            }
            
            function handleMouseMove(e) {
                if (!isResizing) return;
                
                // Cancel any existing animation frame
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }
                
                // Schedule resize in the next animation frame for smoother performance
                animationFrameId = requestAnimationFrame(() => {
                    resize(e);
                    animationFrameId = null;
                });
            }
            
            function resize(e) {
                if (!isResizing) return;
                
                const containerWidth = document.querySelector('.split-layout').offsetWidth;
                const minLeftWidth = 300; // minimum width for left panel
                const maxLeftWidth = Math.min(360, containerWidth * 0.7); // maximum 360px or 70% of container
                const minRightWidth = containerWidth * 0.3; // minimum 30% for right panel
                
                const deltaX = e.clientX - lastDownX;
                const currentLeftWidth = leftPanel.offsetWidth;
                let newLeftWidth = currentLeftWidth + deltaX;
                
                // Constrain by min/max boundaries
                newLeftWidth = Math.max(minLeftWidth, Math.min(maxLeftWidth, newLeftWidth));
                
                // Calculate the percentage of the container width
                const leftWidthPercent = (newLeftWidth / containerWidth) * 100;
                
                // Apply the percentage width - only update DOM once
                leftPanel.style.flex = `0 0 ${leftWidthPercent}%`;
                
                // Store last position for next calculation
                lastDownX = e.clientX;
                
                // We don't update the chart during resize for better performance
                // This will be done after resizing is complete
            }
            
            function stopResize() {
                if (!isResizing) return;
                
                isResizing = false;
                resizeHandle.classList.remove('active');
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                
                // Remove event listeners
                document.removeEventListener('mousemove', handleMouseMove, false);
                document.removeEventListener('mouseup', stopResize, false);
                document.removeEventListener('mouseleave', stopResize, false);
                
                // Cancel any pending animation frame
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                
                // Update chart after resize is complete
                setTimeout(() => {
                    updateChartDisplay();
                    // Flash preview mode indicator to show updated size
                    flashPreviewIndicator();
                }, 100);
            }
            
            // Set event listeners
            resizeHandle.addEventListener('mousedown', initResize);
        })();

        // Add window resize event listener
        window.addEventListener('resize', function() {
            // Reset to percentage-based if window is resized
            const leftPanel = document.querySelector('.left-panel');
            if (leftPanel && leftPanel.style.flex === '') {
                leftPanel.style.flex = '0 0 21%';
            }
            handleWindowResize();
            flashPreviewIndicator();
        });

        resetDimensionsBtn.addEventListener('click', function() {
            chartWidthInput.value = DEFAULT_CHART_WIDTH;
            chartHeightInput.value = DEFAULT_CHART_HEIGHT;
            maintainAspectRatioCheckbox.checked = true;
            previewModeToggle.checked = false; // Keep preview mode disabled
            
            // Update internal values
            chartWidth = DEFAULT_CHART_WIDTH;
            chartHeight = DEFAULT_CHART_HEIGHT;
            aspectRatio = chartWidth / chartHeight;
            maintainAspectRatio = true;
            previewModeEnabled = false; // Keep preview mode disabled
            
            // Update display
            updateChartDisplay();
            
            // Update chart
            if (chartInstance) {
                chartInstance.resize();
            }
            
            showStatus("Chart dimensions reset to default");
        });
        
        // Handle window resize
        window.addEventListener('resize', handleWindowResize);

        // Initial display updates for inputs with value spans
        barPercValueSpan.textContent = barPercentageInput.value;
        catPercValueSpan.textContent = categoryPercentageInput.value;
        innerRadiusValueSpan.textContent = innerRadiusInput.value;
        dataLabelSizeValueSpan.textContent = dataLabelSizeInput.value;
        lineWidthValueSpan.textContent = lineWidthInput.value;

        // Add event listeners for input changes
        barPercentageInput.addEventListener('input', function() {
            barPercValueSpan.textContent = this.value;
            updateChartDisplay();
        });
        
        categoryPercentageInput.addEventListener('input', function() {
            catPercValueSpan.textContent = this.value;
            updateChartDisplay();
        });
        
        innerRadiusInput.addEventListener('input', function() {
            innerRadiusValueSpan.textContent = this.value;
            updateChartDisplay();
        });
        
        dataLabelSizeInput.addEventListener('input', function() {
            dataLabelSizeValueSpan.textContent = this.value;
            updateChartDisplay();
        });

        // Line chart settings events
        toggleCurvedLinesCheckbox.addEventListener('change', function() {
            updateCurveSettingsVisibility();
            if (currentChartData.labels && currentChartData.labels.length > 0) {
                generateChart(currentChartData.labels, currentChartData.datasets);
            }
        });
        
        lineTensionInput.addEventListener('input', function(e) {
            lineTensionValueSpan.textContent = e.target.value;
            if (chartInstance && currentChartData.labels && currentChartData.labels.length > 0) {
                generateChart(currentChartData.labels, currentChartData.datasets);
            }
        });

        // Line width slider event listener
        lineWidthInput.addEventListener('input', function(e) {
            lineWidthValueSpan.textContent = e.target.value;
            if (chartInstance && currentChartData.labels && currentChartData.labels.length > 0) {
                generateChart(currentChartData.labels, currentChartData.datasets);
            }
        });

        // Reset text color button event listener
        if (resetTextColorBtn) {
            resetTextColorBtn.addEventListener('click', function() {
                if (chartTextColorPicker) {
                    chartTextColorPicker.value = '#333333'; // Reset to dark gray
                    if (chartInstance) {
                        updateChartTextColors('#333333');
                    }
                }
            });
        }

        /**
         * Applies the chart dimensions from the input fields.
         */
        function applyChartDimensions() {
            // Get input values
            let newWidth = parseInt(chartWidthInput.value.trim(), 10);
            let newHeight = parseInt(chartHeightInput.value.trim(), 10);
            
            // Validate input
            if (isNaN(newWidth) || isNaN(newHeight)) {
                showError("Width and height must be numbers.");
                return;
            }
            
            // Apply limits (min 200px, max 4000px)
            newWidth = Math.max(200, Math.min(4000, newWidth));
            newHeight = Math.max(200, Math.min(4000, newHeight));
            
            // Update input fields with validated values
            chartWidthInput.value = newWidth;
            chartHeightInput.value = newHeight;
            
            // Store the new dimensions
            chartWidth = newWidth;
            chartHeight = newHeight;
            aspectRatio = chartWidth / chartHeight;
            maintainAspectRatio = maintainAspectRatioCheckbox.checked;
            
            console.log(`Chart dimensions updated: ${chartWidth}x${chartHeight}, aspect ratio: ${aspectRatio.toFixed(2)}`);
            
            // Update chart container and canvas dimensions
            updateChartDisplay();
            
            // Regenerate chart with new dimensions if it exists
            if (chartInstance) {
                // We don't need to destroy and recreate since responsive is true
                chartInstance.resize();
                console.log("Chart resized with new dimensions");
            }
            
            showStatus(`Chart dimensions set to ${chartWidth}x${chartHeight}`);
        }

        // Legend visibility toggle
        if (toggleLegendCheckbox && legendSettings) {
            toggleLegendCheckbox.addEventListener('change', function() {
                legendSettings.style.display = this.checked ? 'block' : 'none';
                if (chartInstance) {
                    generateChart(currentChartData.labels, currentChartData.datasets);
                }
            });
        }

    </script>
</body>
</html>


